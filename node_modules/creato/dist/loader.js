"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const tar = require("tar");
const tmp = require("tmp");
const github = require("parse-github-url");
const fs = require("fs");
const request = require("request");
/** Loaders */
/**
 *
 * Installs template locally.
 *
 * @param template
 * @param output
 */
function loadTemplate(template, output) {
    return __awaiter(this, void 0, void 0, function* () {
        /** Generate tar information. */
        const tar = getRepositoryTarInformation(template);
        /** Download repository to tmp folder. */
        const tmp = yield downloadRepository(tar);
        if (tmp.status === 'err') {
            return {
                status: 'err',
                message: tmp.message,
            };
        }
        /** Extract template from repository to dist. */
        const dist = yield extractTemplateFromRepository(tmp.path, tar, output);
        if (dist.status === 'err') {
            return {
                status: 'err',
                message: dist.message,
            };
        }
        return {
            status: 'ok',
            message: 'Successfully installed template.',
        };
    });
}
exports.loadTemplate = loadTemplate;
/**
 *
 * Generates repository tar information.
 *
 * @param template
 */
function getRepositoryTarInformation(template) {
    const meta = github(template.repo.uri);
    const uri = [
        `https://api.github.com/repos`,
        meta.repo,
        'tarball',
        template.repo.branch,
    ].join('/');
    return { uri, files: template.repo.path };
}
/**
 *
 * Downloads repository tar to temporary folder.
 *
 * @param tar
 */
function downloadRepository(tar) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            const tmpPath = tmp.fileSync({
                postfix: '.tar.gz',
            });
            yield new Promise(resolve => {
                request(tar.uri, {
                    headers: {
                        'User-Agent': 'maticzav/creato',
                    },
                })
                    .pipe(fs.createWriteStream(tmpPath.name))
                    .on('close', resolve);
            });
            return { status: 'ok', path: tmpPath.name };
        }
        catch (err) {
            return { status: 'err', message: err.message };
        }
    });
}
/**
 *
 * Extracts repository from tar to dist.
 *
 * @param tmp
 * @param repo
 * @param output
 */
function extractTemplateFromRepository(tmp, repo, dist) {
    return __awaiter(this, void 0, void 0, function* () {
        try {
            yield tar.extract({
                file: tmp,
                cwd: dist,
                filter: path => RegExp(repo.files).test(path),
                strip: repo.files.split('/').length,
            });
            return { status: 'ok' };
        }
        catch (err) {
            return { status: 'err', message: err.message };
        }
    });
}
//# sourceMappingURL=loader.js.map