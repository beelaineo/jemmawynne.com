"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const inquirer = require("inquirer");
const fs = require("fs");
const path = require("path");
const mkdirp = require("mkdirp");
const __1 = require("../");
const loader = require("../loader");
describe('bin', () => {
    beforeEach(() => {
        jest.restoreAllMocks();
    });
    test('returns on existing directory and no force', () => __awaiter(this, void 0, void 0, function* () {
        const dist = path.resolve(__dirname, './__tmp__/folder');
        /**
         * Mocks
         */
        const inquirerPromptMock = jest
            .spyOn(inquirer, 'prompt')
            .mockResolvedValueOnce({ template: 'template' })
            .mockResolvedValueOnce({ dist: dist });
        const fsExistsSyncMock = jest.spyOn(fs, 'existsSync').mockReturnValue(true);
        const fsMkdirSync = jest.spyOn(mkdirp, 'sync');
        const consoleLogMock = jest.spyOn(console, 'log').mockReturnValue({});
        const consoleWarnMock = jest.spyOn(console, 'warn').mockReturnValue({});
        const loadTemplateMock = jest.spyOn(loader, 'loadTemplate');
        const processExitMock = jest
            .spyOn(process, 'exit')
            .mockImplementation(() => { });
        /**
         * Execution
         */
        yield __1.creato([
            {
                name: 'test-template',
                description: 'test-template description',
                repo: {
                    uri: 'https://github.com/maticzav/creato',
                    branch: 'master',
                    path: '/examples/label-sync',
                },
            },
        ], {
            force: false,
        });
        /**
         * Tests
         */
        expect(inquirerPromptMock).toHaveBeenCalledTimes(2);
        expect(fsExistsSyncMock).toHaveBeenCalledTimes(1);
        expect(fsMkdirSync).toHaveBeenCalledTimes(0);
        expect(consoleLogMock).toHaveBeenCalledTimes(0);
        expect(loadTemplateMock).toHaveBeenCalledTimes(0);
        expect(consoleLogMock).toHaveBeenCalledTimes(0);
        expect(processExitMock).toHaveBeenCalledWith(1);
        expect(consoleWarnMock).toHaveBeenCalledWith(`Directory ${dist} must be empty.`);
    }));
    test('overrides directory on force', () => __awaiter(this, void 0, void 0, function* () {
        const dist = path.resolve(__dirname, 'folder');
        /**
         * Mocks
         */
        const inquirerPromptMock = jest
            .spyOn(inquirer, 'prompt')
            .mockResolvedValueOnce({ template: 'template' })
            .mockResolvedValueOnce({ dist: dist });
        const fsExistsSyncMock = jest.spyOn(fs, 'existsSync').mockReturnValue(false);
        const fsMkdirSync = jest
            .spyOn(mkdirp, 'sync')
            .mockImplementation(() => false);
        const consoleLogMock = jest.spyOn(console, 'log').mockReturnValue({});
        const loadTemplateMock = jest
            .spyOn(loader, 'loadTemplate')
            .mockResolvedValue({ status: 'ok', message: 'pass' });
        const processExitMock = jest
            .spyOn(process, 'exit')
            .mockImplementation(() => { });
        /**
         * Execution
         */
        yield __1.creato([
            {
                name: 'test-template',
                description: 'test-template description',
                repo: {
                    uri: 'https://github.com/maticzav/creato',
                    branch: 'master',
                    path: '/examples/label-sync',
                },
            },
        ], {
            force: true,
        });
        /**
         * Tests
         */
        expect(inquirerPromptMock).toHaveBeenCalledTimes(2);
        expect(fsExistsSyncMock).toHaveBeenCalledTimes(1);
        expect(fsMkdirSync).toHaveBeenCalledTimes(1);
        expect(consoleLogMock).toHaveBeenCalledTimes(1);
        expect(loadTemplateMock).toHaveBeenCalledTimes(1);
        expect(consoleLogMock).toHaveBeenCalledWith('pass');
        expect(processExitMock).toBeCalledWith(0);
    }));
    test('logs success on success', () => __awaiter(this, void 0, void 0, function* () {
        const dist = path.resolve(__dirname, 'folder');
        /**
         * Mocks
         */
        const inquirerPromptMock = jest
            .spyOn(inquirer, 'prompt')
            .mockResolvedValueOnce({ template: 'template' })
            .mockResolvedValueOnce({ dist: dist });
        const fsExistsSyncMock = jest.spyOn(fs, 'existsSync').mockReturnValue(false);
        const fsMkdirSync = jest
            .spyOn(mkdirp, 'sync')
            .mockImplementation(() => false);
        const consoleLogMock = jest.spyOn(console, 'log').mockReturnValue({});
        const loadTemplateMock = jest
            .spyOn(loader, 'loadTemplate')
            .mockResolvedValue({ status: 'ok', message: 'pass' });
        const processExitMock = jest
            .spyOn(process, 'exit')
            .mockImplementation(() => { });
        /**
         * Execution
         */
        yield __1.creato([
            {
                name: 'test-template',
                description: 'test-template description',
                repo: {
                    uri: 'https://github.com/maticzav/creato',
                    branch: 'master',
                    path: '/examples/label-sync',
                },
            },
        ], {
            force: false,
        });
        /**
         * Tests
         */
        expect(inquirerPromptMock).toHaveBeenCalledTimes(2);
        expect(fsExistsSyncMock).toHaveBeenCalledTimes(1);
        expect(fsMkdirSync).toHaveBeenCalledTimes(1);
        expect(consoleLogMock).toHaveBeenCalledTimes(1);
        expect(loadTemplateMock).toHaveBeenCalledTimes(1);
        expect(consoleLogMock).toHaveBeenCalledWith('pass');
        expect(processExitMock).toBeCalledWith(0);
    }));
    test('warns error on error', () => __awaiter(this, void 0, void 0, function* () {
        const dist = path.resolve(__dirname, 'folder');
        /**
         * Mocks
         */
        const inquirerPromptMock = jest
            .spyOn(inquirer, 'prompt')
            .mockResolvedValueOnce({ template: 'template' })
            .mockResolvedValueOnce({ dist: dist });
        const fsExistsSyncMock = jest.spyOn(fs, 'existsSync').mockReturnValue(false);
        const fsMkdirSync = jest
            .spyOn(mkdirp, 'sync')
            .mockImplementation(() => false);
        const consoleLogMock = jest.spyOn(console, 'log').mockReturnValue({});
        const consoleWarnMock = jest.spyOn(console, 'warn').mockReturnValue({});
        const loadTemplateMock = jest
            .spyOn(loader, 'loadTemplate')
            .mockResolvedValue({ status: 'err', message: 'pass' });
        const processExitMock = jest
            .spyOn(process, 'exit')
            .mockImplementation(() => { });
        /**
         * Execution
         */
        yield __1.creato([
            {
                name: 'test-template',
                description: 'test-template description',
                repo: {
                    uri: 'https://github.com/maticzav/creato',
                    branch: 'master',
                    path: '/examples/label-sync',
                },
            },
        ], {
            force: false,
        });
        /**
         * Tests
         */
        expect(inquirerPromptMock).toHaveBeenCalledTimes(2);
        expect(fsExistsSyncMock).toHaveBeenCalledTimes(1);
        expect(fsMkdirSync).toHaveBeenCalledTimes(1);
        expect(consoleLogMock).toHaveBeenCalledTimes(0);
        expect(consoleWarnMock).toHaveBeenCalledTimes(1);
        expect(loadTemplateMock).toHaveBeenCalledTimes(1);
        expect(consoleWarnMock).toHaveBeenCalledWith('pass');
        expect(processExitMock).toBeCalledWith(1);
    }));
});
//# sourceMappingURL=creato.test.js.map