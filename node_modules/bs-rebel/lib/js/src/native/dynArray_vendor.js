'use strict';

var Obj = require("bs-platform/lib/js/obj.js");
var Sys = require("bs-platform/lib/js/sys.js");
var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Caml_exceptions = require("bs-platform/lib/js/caml_exceptions.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function idup(x) {
  if (x.length === 0) {
    return x;
  } else {
    return Caml_obj.caml_obj_dup(x);
  }
}

var Invalid_arg = Caml_exceptions.create("DynArray_vendor-BsRebel.Invalid_arg");

function invalid_arg(n, f, p) {
  throw [
        Invalid_arg,
        n,
        f,
        p
      ];
}

function length(d) {
  return d[/* len */1];
}

function exponential_resizer(currslots, oldlength, newlength) {
  var doubler = function (_x) {
    while(true) {
      var x = _x;
      if (x >= newlength) {
        return x;
      } else {
        _x = (x << 1);
        continue ;
      }
    };
  };
  if (newlength === 1) {
    return 1;
  } else if (currslots === 0) {
    return doubler(1);
  } else if (currslots < newlength) {
    return doubler(currslots);
  } else {
    var _x = currslots;
    while(true) {
      var x = _x;
      if ((x / 2 | 0) < newlength) {
        return x;
      } else {
        _x = x / 2 | 0;
        continue ;
      }
    };
  }
}

function step_resizer(step) {
  if (step <= 0) {
    invalid_arg(step, "step_resizer", "step");
  }
  return (function (currslots, oldlength, newlength) {
      if (currslots < newlength || newlength < (currslots - step | 0)) {
        return (newlength + step | 0) - Caml_int32.mod_(newlength, step) | 0;
      } else {
        return currslots;
      }
    });
}

function conservative_exponential_resizer(currslots, oldlength, newlength) {
  var doubler = function (_x) {
    while(true) {
      var x = _x;
      if (x >= newlength) {
        return x;
      } else {
        _x = (x << 1);
        continue ;
      }
    };
  };
  if (currslots < newlength) {
    if (newlength === 1) {
      return 1;
    } else if (currslots === 0) {
      return doubler(1);
    } else {
      return doubler(currslots);
    }
  } else if (oldlength < newlength) {
    var _x = currslots;
    while(true) {
      var x = _x;
      if ((x / 2 | 0) < newlength) {
        return x;
      } else {
        _x = x / 2 | 0;
        continue ;
      }
    };
  } else {
    return currslots;
  }
}

function changelen(d, newlen) {
  if (newlen > Sys.max_array_length) {
    invalid_arg(newlen, "changelen", "newlen");
  }
  var oldsize = d[/* arr */0].length;
  var r = Curry._3(d[/* resize */2], oldsize, d[/* len */1], newlen);
  var newsize = r < newlen ? newlen : (
      Sys.max_array_length < r ? Sys.max_array_length : r
    );
  if (newsize !== oldsize) {
    var newarr = Caml_obj.caml_obj_block(0, newsize);
    var cpylen = newlen < d[/* len */1] ? newlen : d[/* len */1];
    for(var i = 0 ,i_finish = cpylen - 1 | 0; i <= i_finish; ++i){
      newarr[i] = d[/* arr */0][i];
    }
    d[/* arr */0] = newarr;
  }
  d[/* len */1] = newlen;
  return /* () */0;
}

function compact(d) {
  if (d[/* len */1] !== d[/* arr */0].length) {
    var newarr = Caml_obj.caml_obj_block(0, d[/* len */1]);
    for(var i = 0 ,i_finish = d[/* len */1] - 1 | 0; i <= i_finish; ++i){
      newarr[i] = d[/* arr */0][i];
    }
    d[/* arr */0] = newarr;
    return /* () */0;
  } else {
    return 0;
  }
}

function create(param) {
  return /* record */[
          /* arr */[],
          /* len */0,
          /* resize */conservative_exponential_resizer
        ];
}

function make(initsize) {
  if (initsize < 0) {
    invalid_arg(initsize, "make", "size");
  }
  return /* record */[
          /* arr */Caml_obj.caml_obj_block(0, initsize),
          /* len */0,
          /* resize */conservative_exponential_resizer
        ];
}

function init(initlen, f) {
  if (initlen < 0) {
    invalid_arg(initlen, "init", "len");
  }
  var arr = Caml_obj.caml_obj_block(0, initlen);
  for(var i = 0 ,i_finish = initlen - 1 | 0; i <= i_finish; ++i){
    arr[i] = Curry._1(f, i);
  }
  return /* record */[
          /* arr */arr,
          /* len */initlen,
          /* resize */conservative_exponential_resizer
        ];
}

function set_resizer(d, resizer) {
  d[/* resize */2] = resizer;
  return /* () */0;
}

function get_resizer(d) {
  return d[/* resize */2];
}

function empty(d) {
  return d[/* len */1] === 0;
}

function get(d, idx) {
  if (idx < 0 || idx >= d[/* len */1]) {
    invalid_arg(idx, "get", "index");
  }
  return d[/* arr */0][idx];
}

function last(d) {
  if (d[/* len */1] === 0) {
    invalid_arg(0, "last", "<array len is 0>");
  }
  return d[/* arr */0][d[/* len */1] - 1 | 0];
}

function set(d, idx, v) {
  if (idx < 0 || idx >= d[/* len */1]) {
    invalid_arg(idx, "set", "index");
  }
  d[/* arr */0][idx] = v;
  return /* () */0;
}

function insert(d, idx, v) {
  if (idx < 0 || idx > d[/* len */1]) {
    invalid_arg(idx, "insert", "index");
  }
  if (d[/* len */1] === d[/* arr */0].length) {
    changelen(d, d[/* len */1] + 1 | 0);
  } else {
    d[/* len */1] = d[/* len */1] + 1 | 0;
  }
  if (idx < (d[/* len */1] - 1 | 0)) {
    for(var i = d[/* len */1] - 2 | 0; i >= idx; --i){
      d[/* arr */0][i + 1 | 0] = d[/* arr */0][i];
    }
  }
  d[/* arr */0][idx] = v;
  return /* () */0;
}

function add(d, v) {
  if (d[/* len */1] === d[/* arr */0].length) {
    changelen(d, d[/* len */1] + 1 | 0);
  } else {
    d[/* len */1] = d[/* len */1] + 1 | 0;
  }
  d[/* arr */0][d[/* len */1] - 1 | 0] = v;
  return /* () */0;
}

function $$delete(d, idx) {
  if (idx < 0 || idx >= d[/* len */1]) {
    invalid_arg(idx, "delete", "index");
  }
  var oldsize = d[/* arr */0].length;
  var r = Curry._3(d[/* resize */2], oldsize, d[/* len */1], d[/* len */1] - 1 | 0);
  var newsize = r < (d[/* len */1] - 1 | 0) ? d[/* len */1] - 1 | 0 : r;
  if (oldsize !== newsize) {
    var newarr = Caml_obj.caml_obj_block(0, newsize);
    for(var i = 0 ,i_finish = idx - 1 | 0; i <= i_finish; ++i){
      newarr[i] = d[/* arr */0][i];
    }
    for(var i$1 = idx ,i_finish$1 = d[/* len */1] - 2 | 0; i$1 <= i_finish$1; ++i$1){
      newarr[i$1] = d[/* arr */0][i$1 + 1 | 0];
    }
    d[/* arr */0] = newarr;
  } else {
    for(var i$2 = idx ,i_finish$2 = d[/* len */1] - 2 | 0; i$2 <= i_finish$2; ++i$2){
      d[/* arr */0][i$2] = d[/* arr */0][i$2 + 1 | 0];
    }
    d[/* arr */0][d[/* len */1] - 1 | 0] = 0;
  }
  d[/* len */1] = d[/* len */1] - 1 | 0;
  return /* () */0;
}

function delete_range(d, idx, len) {
  if (len < 0) {
    invalid_arg(len, "delete_range", "length");
  }
  if (idx < 0 || (idx + len | 0) > d[/* len */1]) {
    invalid_arg(idx, "delete_range", "index");
  }
  var oldsize = d[/* arr */0].length;
  var r = Curry._3(d[/* resize */2], oldsize, d[/* len */1], d[/* len */1] - len | 0);
  var newsize = r < (d[/* len */1] - len | 0) ? d[/* len */1] - len | 0 : r;
  if (oldsize !== newsize) {
    var newarr = Caml_obj.caml_obj_block(0, newsize);
    for(var i = 0 ,i_finish = idx - 1 | 0; i <= i_finish; ++i){
      newarr[i] = d[/* arr */0][i];
    }
    for(var i$1 = idx ,i_finish$1 = (d[/* len */1] - len | 0) - 1 | 0; i$1 <= i_finish$1; ++i$1){
      newarr[i$1] = d[/* arr */0][i$1 + len | 0];
    }
    d[/* arr */0] = newarr;
  } else {
    for(var i$2 = idx ,i_finish$2 = (d[/* len */1] - len | 0) - 1 | 0; i$2 <= i_finish$2; ++i$2){
      d[/* arr */0][i$2] = d[/* arr */0][i$2 + len | 0];
    }
    for(var i$3 = d[/* len */1] - len | 0 ,i_finish$3 = d[/* len */1] - 1 | 0; i$3 <= i_finish$3; ++i$3){
      d[/* arr */0][i$3] = 0;
    }
  }
  d[/* len */1] = d[/* len */1] - len | 0;
  return /* () */0;
}

function clear(d) {
  d[/* len */1] = 0;
  d[/* arr */0] = [];
  return /* () */0;
}

function delete_last(d) {
  if (d[/* len */1] <= 0) {
    invalid_arg(0, "delete_last", "<array len is 0>");
  }
  d[/* arr */0][d[/* len */1] - 1 | 0] = 0;
  return changelen(d, d[/* len */1] - 1 | 0);
}

function blit(src, srcidx, dst, dstidx, len) {
  if (len < 0) {
    invalid_arg(len, "blit", "len");
  }
  if (srcidx < 0 || (srcidx + len | 0) > src[/* len */1]) {
    invalid_arg(srcidx, "blit", "source index");
  }
  if (dstidx < 0 || dstidx > dst[/* len */1]) {
    invalid_arg(dstidx, "blit", "dest index");
  }
  var newlen = dstidx + len | 0;
  if (newlen > dst[/* arr */0].length) {
    changelen(dst, newlen);
  } else if (newlen > dst[/* len */1]) {
    dst[/* len */1] = newlen;
  }
  if (src[/* arr */0] === dst[/* arr */0] && dstidx > srcidx) {
    for(var i = len - 1 | 0; i >= 0; --i){
      dst[/* arr */0][dstidx + i | 0] = src[/* arr */0][srcidx + i | 0];
    }
    return /* () */0;
  } else {
    for(var i$1 = 0 ,i_finish = len - 1 | 0; i$1 <= i_finish; ++i$1){
      dst[/* arr */0][dstidx + i$1 | 0] = src[/* arr */0][srcidx + i$1 | 0];
    }
    return /* () */0;
  }
}

function append(src, dst) {
  return blit(src, 0, dst, dst[/* len */1], src[/* len */1]);
}

function to_list(d) {
  var _idx = d[/* len */1] - 1 | 0;
  var _accum = /* [] */0;
  while(true) {
    var accum = _accum;
    var idx = _idx;
    if (idx < 0) {
      return accum;
    } else {
      _accum = /* :: */[
        d[/* arr */0][idx],
        accum
      ];
      _idx = idx - 1 | 0;
      continue ;
    }
  };
}

function to_array(d) {
  if (d[/* len */1] === 0) {
    return /* array */[];
  } else {
    var arr = Caml_array.caml_make_vect(d[/* len */1], d[/* arr */0][0]);
    for(var i = 1 ,i_finish = d[/* len */1] - 1 | 0; i <= i_finish; ++i){
      arr[i] = d[/* arr */0][i];
    }
    return arr;
  }
}

function of_list(lst) {
  var size = List.length(lst);
  var arr = Caml_obj.caml_obj_block(0, size);
  var loop = function (_idx, _param) {
    while(true) {
      var param = _param;
      var idx = _idx;
      if (param) {
        arr[idx] = param[0];
        _param = param[1];
        _idx = idx + 1 | 0;
        continue ;
      } else {
        return /* () */0;
      }
    };
  };
  loop(0, lst);
  return /* record */[
          /* arr */arr,
          /* len */size,
          /* resize */conservative_exponential_resizer
        ];
}

function of_array(src) {
  var size = src.length;
  var is_float = (src.tag | 0) === Obj.double_array_tag;
  var arr;
  if (is_float) {
    var arr$1 = Caml_obj.caml_obj_block(0, size);
    for(var i = 0 ,i_finish = size - 1 | 0; i <= i_finish; ++i){
      arr$1[i] = src[i];
    }
    arr = arr$1;
  } else {
    arr = idup(src);
  }
  return /* record */[
          /* arr */arr,
          /* len */size,
          /* resize */conservative_exponential_resizer
        ];
}

function copy(src) {
  return /* record */[
          /* arr */idup(src[/* arr */0]),
          /* len */src[/* len */1],
          /* resize */src[/* resize */2]
        ];
}

function sub(src, start, len) {
  if (len < 0) {
    invalid_arg(len, "sub", "len");
  }
  if (start < 0 || (start + len | 0) > src[/* len */1]) {
    invalid_arg(start, "sub", "start");
  }
  var arr = Caml_obj.caml_obj_block(0, len);
  for(var i = 0 ,i_finish = len - 1 | 0; i <= i_finish; ++i){
    arr[i] = src[/* arr */0][i + start | 0];
  }
  return /* record */[
          /* arr */arr,
          /* len */len,
          /* resize */src[/* resize */2]
        ];
}

function iter(f, d) {
  for(var i = 0 ,i_finish = d[/* len */1] - 1 | 0; i <= i_finish; ++i){
    Curry._1(f, d[/* arr */0][i]);
  }
  return /* () */0;
}

function iteri(f, d) {
  for(var i = 0 ,i_finish = d[/* len */1] - 1 | 0; i <= i_finish; ++i){
    Curry._2(f, i, d[/* arr */0][i]);
  }
  return /* () */0;
}

function filter(f, d) {
  var l = d[/* len */1];
  var a = Caml_obj.caml_obj_block(0, l);
  var a2 = d[/* arr */0];
  var p = 0;
  for(var i = 0 ,i_finish = l - 1 | 0; i <= i_finish; ++i){
    var x = a2[i];
    if (Curry._1(f, x)) {
      a[p] = x;
      p = p + 1 | 0;
    }
    
  }
  d[/* len */1] = p;
  d[/* arr */0] = a;
  return /* () */0;
}

function index_of(f, d) {
  var _i = 0;
  while(true) {
    var i = _i;
    if (i >= d[/* len */1]) {
      throw Caml_builtin_exceptions.not_found;
    } else if (Curry._1(f, d[/* arr */0][i])) {
      return i;
    } else {
      _i = i + 1 | 0;
      continue ;
    }
  };
}

function map(f, src) {
  var arr = Caml_obj.caml_obj_block(0, src[/* len */1]);
  for(var i = 0 ,i_finish = src[/* len */1] - 1 | 0; i <= i_finish; ++i){
    arr[i] = Curry._1(f, src[/* arr */0][i]);
  }
  return /* record */[
          /* arr */arr,
          /* len */src[/* len */1],
          /* resize */src[/* resize */2]
        ];
}

function mapi(f, src) {
  var arr = Caml_obj.caml_obj_block(0, src[/* len */1]);
  for(var i = 0 ,i_finish = src[/* len */1] - 1 | 0; i <= i_finish; ++i){
    arr[i] = Curry._2(f, i, src[/* arr */0][i]);
  }
  return /* record */[
          /* arr */arr,
          /* len */src[/* len */1],
          /* resize */src[/* resize */2]
        ];
}

function fold_left(f, x, a) {
  var _idx = 0;
  var _x = x;
  while(true) {
    var x$1 = _x;
    var idx = _idx;
    if (idx >= a[/* len */1]) {
      return x$1;
    } else {
      _x = Curry._2(f, x$1, a[/* arr */0][idx]);
      _idx = idx + 1 | 0;
      continue ;
    }
  };
}

function fold_right(f, a, x) {
  var _idx = a[/* len */1] - 1 | 0;
  var _x = x;
  while(true) {
    var x$1 = _x;
    var idx = _idx;
    if (idx < 0) {
      return x$1;
    } else {
      _x = Curry._2(f, a[/* arr */0][idx], x$1);
      _idx = idx - 1 | 0;
      continue ;
    }
  };
}

function unsafe_get(a, n) {
  return a[/* arr */0][n];
}

function unsafe_set(a, n, x) {
  a[/* arr */0][n] = x;
  return /* () */0;
}

var default_resizer = conservative_exponential_resizer;

exports.Invalid_arg = Invalid_arg;
exports.create = create;
exports.make = make;
exports.init = init;
exports.empty = empty;
exports.length = length;
exports.get = get;
exports.last = last;
exports.set = set;
exports.insert = insert;
exports.add = add;
exports.append = append;
exports.$$delete = $$delete;
exports.delete_last = delete_last;
exports.delete_range = delete_range;
exports.clear = clear;
exports.blit = blit;
exports.compact = compact;
exports.to_list = to_list;
exports.to_array = to_array;
exports.of_list = of_list;
exports.of_array = of_array;
exports.copy = copy;
exports.sub = sub;
exports.iter = iter;
exports.iteri = iteri;
exports.map = map;
exports.mapi = mapi;
exports.fold_left = fold_left;
exports.fold_right = fold_right;
exports.index_of = index_of;
exports.filter = filter;
exports.set_resizer = set_resizer;
exports.get_resizer = get_resizer;
exports.default_resizer = default_resizer;
exports.exponential_resizer = exponential_resizer;
exports.step_resizer = step_resizer;
exports.conservative_exponential_resizer = conservative_exponential_resizer;
exports.unsafe_get = unsafe_get;
exports.unsafe_set = unsafe_set;
/* No side effect */
