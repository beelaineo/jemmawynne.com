"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var graphcool_ts_1 = require("./graphcool-ts");
exports.generator = __assign({}, graphcool_ts_1.generator, { Main: renderMainMethod, Header: renderHeader });
var scalarMapping = {
    Int: 'number',
    String: 'string',
    ID: 'string | number',
    Float: 'number',
    Boolean: 'boolean'
};
function renderHeader(schema) {
    return "import { Prisma as BasePrisma, BasePrismaOptions } from 'prisma-binding'\nimport { GraphQLResolveInfo } from 'graphql'\n\nexport const typeDefs = `\n" + schema + "`";
}
function renderMainMethod(queryType, mutationType, subscriptionType) {
    return "export class Prisma extends BasePrisma {\n  \n  constructor({ endpoint, secret, fragmentReplacements, debug }: BasePrismaOptions) {\n    super({ typeDefs, endpoint, secret, fragmentReplacements, debug });\n  }\n\n  exists = {\n" + graphcool_ts_1.renderExistsFields(queryType.getFields()) + "\n  }\n\n  query: Query = {\n" + graphcool_ts_1.renderMainMethodFields('query', queryType.getFields()) + "\n  }" + (mutationType
        ? "\n\n  mutation: Mutation = {\n" + graphcool_ts_1.renderMainMethodFields('mutation', mutationType.getFields()) + "\n  }"
        : '') + (subscriptionType
        ? "\n\n  subscription: Subscription = {\n" + graphcool_ts_1.renderMainSubscriptionMethodFields(subscriptionType.getFields()) + "\n  }"
        : '') + "\n}";
}
//# sourceMappingURL=prisma-ts.js.map