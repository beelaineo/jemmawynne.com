'use strict';

Object.defineProperty(exports, "__esModule", {
	value: true
});

var _slicedToArray2 = require('babel-runtime/helpers/slicedToArray');

var _slicedToArray3 = _interopRequireDefault(_slicedToArray2);

var _chalk = require('chalk');

var _chalk2 = _interopRequireDefault(_chalk);

var _enumRuleIsActive = require('./enum-rule-is-active');

var _enumRuleIsActive2 = _interopRequireDefault(_enumRuleIsActive);

var _format = require('./format');

var _format2 = _interopRequireDefault(_format);

var _getForcedCaseFn = require('./get-forced-case-fn');

var _getForcedCaseFn2 = _interopRequireDefault(_getForcedCaseFn);

var _getForcedLeadingFn = require('./get-forced-leading-fn');

var _getForcedLeadingFn2 = _interopRequireDefault(_getForcedLeadingFn);

var _getHasName = require('./get-has-name');

var _getHasName2 = _interopRequireDefault(_getHasName);

var _meta = require('./meta');

var _meta2 = _interopRequireDefault(_meta);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = getPrompt;

/**
 * Get a cli prompt based on rule configuration
 * @param  {string} type     type of the data to gather
 * @param  {object} context     rules to parse
 * @return {object}          prompt instance
 */

function getPrompt(type, context = {}) {
	var _context$rules = context.rules;
	const rules = _context$rules === undefined ? [] : _context$rules;
	var _context$settings = context.settings;
	const settings = _context$settings === undefined ? {} : _context$settings;
	var _context$results = context.results;
	const results = _context$results === undefined ? {} : _context$results,
	      prompter = context.prompter;


	if (typeof prompter !== 'function') {
		throw new TypeError('Missing prompter function in getPrompt context');
	}

	const prompt = prompter();

	if (typeof prompt.removeAllListeners !== 'function') {
		throw new TypeError('getPrompt: prompt.removeAllListeners is not a function');
	}

	if (typeof prompt.command !== 'function') {
		throw new TypeError('getPrompt: prompt.command is not a function');
	}

	if (typeof prompt.catch !== 'function') {
		throw new TypeError('getPrompt: prompt.catch is not a function');
	}

	if (typeof prompt.addListener !== 'function') {
		throw new TypeError('getPrompt: prompt.addListener is not a function');
	}

	if (typeof prompt.log !== 'function') {
		throw new TypeError('getPrompt: prompt.log is not a function');
	}

	if (typeof prompt.delimiter !== 'function') {
		throw new TypeError('getPrompt: prompt.delimiter is not a function');
	}

	if (typeof prompt.show !== 'function') {
		throw new TypeError('getPrompt: prompt.show is not a function');
	}

	const enumRule = rules.filter((0, _getHasName2.default)('enum')).filter(_enumRuleIsActive2.default)[0];

	const emptyRule = rules.filter((0, _getHasName2.default)('empty'))[0];

	const mustBeEmpty = emptyRule ? emptyRule[1][0] > 0 && emptyRule[1][1] === 'always' : false;

	const mayNotBeEmpty = emptyRule ? emptyRule[1][0] > 0 && emptyRule[1][1] === 'never' : false;

	const mayBeEmpty = !mayNotBeEmpty;

	if (mustBeEmpty) {
		prompt.removeAllListeners('keypress');
		prompt.removeAllListeners('client_prompt_submit');
		prompt.ui.redraw.done();
		return Promise.resolve();
	}

	const caseRule = rules.filter((0, _getHasName2.default)('case'))[0];

	const forceCaseFn = (0, _getForcedCaseFn2.default)(caseRule);

	const leadingBlankRule = rules.filter((0, _getHasName2.default)('leading-blank'))[0];

	const forceLeadingBlankFn = (0, _getForcedLeadingFn2.default)(leadingBlankRule);

	const maxLenghtRule = rules.filter((0, _getHasName2.default)('max-length'))[0];

	const hasMaxLength = maxLenghtRule && maxLenghtRule[1][0] > 0;

	const inputMaxLength = hasMaxLength ? maxLenghtRule[1][1] : Infinity;

	const headerLength = settings.header ? settings.header.length : Infinity;

	const remainingHeaderLength = headerLength ? headerLength - [results.type, results.scope, results.scope ? '()' : '', results.type && results.scope ? ':' : '', results.subject].join('').length : Infinity;

	const maxLength = Math.min(inputMaxLength, remainingHeaderLength);

	return new Promise(resolve => {
		// Add the defined enums as sub commands if applicable
		if (enumRule) {
			var _enumRule = (0, _slicedToArray3.default)(enumRule, 2),
			    _enumRule$ = (0, _slicedToArray3.default)(_enumRule[1], 3);

			const enums = _enumRule$[2];


			enums.forEach(enumerable => {
				const enumSettings = (settings.enumerables || {})[enumerable] || {};
				prompt.command(enumerable).description(enumSettings.description || '').action(() => {
					prompt.removeAllListeners();
					prompt.ui.redraw.done();
					return resolve(forceLeadingBlankFn(forceCaseFn(enumerable)));
				});
			});
		} else {
			prompt.catch('[text...]').action(parameters => {
				var _parameters$text = parameters.text;
				const text = _parameters$text === undefined ? '' : _parameters$text;

				prompt.removeAllListeners();
				prompt.ui.redraw.done();
				return resolve(forceLeadingBlankFn(forceCaseFn(text.join(' '))));
			});
		}

		if (mayBeEmpty) {
			// Add an easy exit command
			prompt.command(':skip').description('Skip the input if possible.').action(() => {
				prompt.removeAllListeners();
				prompt.ui.redraw.done();
				resolve('');
			});
		}

		// Handle empty input
		const onSubmit = input => {
			if (input.length > 0) {
				return;
			}

			// Show help if enum is defined and input may not be empty
			if (mayNotBeEmpty) {
				prompt.ui.log(_chalk2.default.yellow(`⚠ ${_chalk2.default.bold(type)} may not be empty.`));
			}

			if (mayBeEmpty) {
				prompt.ui.log(_chalk2.default.blue(`ℹ Enter ${_chalk2.default.bold(':skip')} to omit ${_chalk2.default.bold(type)}.`));
			}

			if (enumRule) {
				prompt.exec('help');
			}
		};

		const drawRemaining = length => {
			if (length < Infinity) {
				const colors = [{
					threshold: 5,
					color: 'red'
				}, {
					threshold: 10,
					color: 'yellow'
				}, {
					threshold: Infinity,
					color: 'grey'
				}];

				const color = colors.filter(item => {
					return item.threshold >= length;
				}).map(item => item.color)[0];

				prompt.ui.redraw(_chalk2.default[color](`${length} characters left`));
			}
		};

		const onKey = event => {
			const sanitized = forceCaseFn(event.value);
			const cropped = sanitized.slice(0, maxLength);

			// We **could** do live editing, but there are some quirks to solve
			/* const live = merge({}, results, {
   	[type]: cropped
   });
   prompt.ui.redraw(`\n\n${format(live, true)}\n\n`); */

			if (maxLength) {
				drawRemaining(maxLength - cropped.length);
			}
			prompt.ui.input(cropped);
		};

		prompt.addListener('keypress', onKey);
		prompt.addListener('client_prompt_submit', onSubmit);

		prompt.log(`\n\nPlease enter a ${_chalk2.default.bold(type)}: ${(0, _meta2.default)({
			optional: !mayNotBeEmpty,
			required: mayNotBeEmpty,
			'tab-completion': typeof enumRule !== 'undefined',
			header: typeof settings.header !== 'undefined',
			'multi-line': settings.multiline
		})}`);

		if (settings.description) {
			prompt.log(_chalk2.default.grey(`${settings.description}\n`));
		}

		prompt.log(`\n\n${(0, _format2.default)(results, true)}\n\n`);

		drawRemaining(maxLength);

		prompt.delimiter(`❯ ${type}:`).show();
	});
}
module.exports = exports['default'];
//# sourceMappingURL=get-prompt.js.map