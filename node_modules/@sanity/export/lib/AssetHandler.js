"use strict";

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var path = require('path');

var crypto = require('crypto');

var _require = require('url'),
    parseUrl = _require.parse,
    formatUrl = _require.format;

var fse = require('fs-extra');

var miss = require('mississippi');

var PQueue = require('p-queue');

var _require2 = require('lodash'),
    omit = _require2.omit,
    noop = _require2.noop;

var pkg = require('../package.json');

var requestStream = require('./requestStream');

var debug = require('./debug');

var EXCLUDE_PROPS = ['_id', '_type', 'assetId', 'extension', 'mimeType', 'path', 'url'];
var ACTION_REMOVE = 'remove';
var ACTION_REWRITE = 'rewrite';

class AssetHandler {
  constructor(options) {
    var _this = this;

    _defineProperty(this, "rewriteAssets", miss.through.obj(
    /*#__PURE__*/
    function () {
      var _ref = _asyncToGenerator(function* (doc, enc, callback) {
        if (['sanity.imageAsset', 'sanity.fileAsset'].includes(doc._type)) {
          var type = doc._type === 'sanity.imageAsset' ? 'image' : 'file';
          var filePath = `${type}s/${generateFilename(doc._id)}`;

          _this.assetsSeen.set(doc._id, type);

          _this.queueAssetDownload(doc, filePath, type);

          callback();
          return;
        }

        callback(null, (yield _this.findAndModify(doc, ACTION_REWRITE)));
      });

      return function (_x, _x2, _x3) {
        return _ref.apply(this, arguments);
      };
    }()));

    _defineProperty(this, "stripAssets", miss.through.obj(
    /*#__PURE__*/
    function () {
      var _ref2 = _asyncToGenerator(function* (doc, enc, callback) {
        if (['sanity.imageAsset', 'sanity.fileAsset'].includes(doc._type)) {
          callback();
          return;
        }

        callback(null, (yield _this.findAndModify(doc, ACTION_REMOVE)));
      });

      return function (_x4, _x5, _x6) {
        return _ref2.apply(this, arguments);
      };
    }()));

    _defineProperty(this, "skipAssets", miss.through.obj((doc, enc, callback) => {
      var isAsset = ['sanity.imageAsset', 'sanity.fileAsset'].includes(doc._type);

      if (isAsset) {
        callback();
        return;
      }

      callback(null, doc);
    }));

    _defineProperty(this, "noop", miss.through.obj((doc, enc, callback) => callback(null, doc)));

    _defineProperty(this, "findAndModify",
    /*#__PURE__*/
    function () {
      var _ref3 = _asyncToGenerator(function* (item, action) {
        if (Array.isArray(item)) {
          var children = yield Promise.all(item.map(child => _this.findAndModify(child, action)));
          return children.filter(Boolean);
        }

        if (!item || typeof item !== 'object') {
          return item;
        }

        var isAsset = isAssetField(item);

        if (isAsset && action === ACTION_REMOVE) {
          return undefined;
        }

        if (isAsset && action === ACTION_REWRITE) {
          var asset = item.asset,
              other = _objectWithoutProperties(item, ["asset"]);

          var assetId = asset._ref;

          if (isModernAsset(assetId)) {
            var assetType = getAssetType(item);
            var _filePath = `${assetType}s/${generateFilename(assetId)}`;
            return _objectSpread({
              _sanityAsset: `${assetType}@file://./${_filePath}`
            }, (yield _this.findAndModify(other, action)));
          } // Legacy asset


          var type = _this.assetsSeen.get(assetId) || (yield _this.lookupAssetType(assetId));
          var filePath = `${type}s/${generateFilename(assetId)}`;
          return _objectSpread({
            _sanityAsset: `${type}@file://./${filePath}`
          }, (yield _this.findAndModify(other, action)));
        }

        var newItem = {};
        var keys = Object.keys(item);

        for (var i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = item[key]; // eslint-disable-next-line no-await-in-loop

          newItem[key] = yield _this.findAndModify(value, action);

          if (typeof newItem[key] === 'undefined') {
            delete newItem[key];
          }
        }

        return newItem;
      });

      return function (_x7, _x8) {
        return _ref3.apply(this, arguments);
      };
    }());

    _defineProperty(this, "lookupAssetType",
    /*#__PURE__*/
    function () {
      var _ref4 = _asyncToGenerator(function* (assetId) {
        var docType = yield _this.client.fetch('*[_id == $id][0]._type', {
          id: assetId
        });
        return docType === 'sanity.imageAsset' ? 'image' : 'file';
      });

      return function (_x9) {
        return _ref4.apply(this, arguments);
      };
    }());

    this.client = options.client;
    this.tmpDir = options.tmpDir;
    this.assetDirsCreated = false;
    this.assetsSeen = new Map();
    this.assetMap = {};
    this.filesWritten = 0;
    this.queueSize = 0;
    this.queue = options.queue || new PQueue({
      concurrency: 3
    });
    this.rejectedError = null;

    this.reject = err => {
      this.rejectedError = err;
    };
  }

  clear() {
    this.assetsSeen.clear();
    this.queue.clear();
    this.queueSize = 0;
  }

  finish() {
    return new Promise((resolve, reject) => {
      if (this.rejectedError) {
        reject(this.rejectedError);
        return;
      }

      this.reject = reject;
      this.queue.onIdle().then(() => resolve(this.assetMap));
    });
  } // Called when we want to download all assets to local filesystem and rewrite documents to hold
  // placeholder asset references (_sanityAsset: 'image@file:///local/path')


  queueAssetDownload(assetDoc, dstPath, type) {
    if (!assetDoc.url) {
      debug('Asset document "%s" does not have a URL property, skipping', assetDoc._id);
      return;
    }

    debug('Adding download task for %s (destination: %s)', assetDoc._id, dstPath);
    this.queueSize++;
    this.queue.add(() => this.downloadAsset(assetDoc, dstPath));
  }

  maybeCreateAssetDirs() {
    if (this.assetDirsCreated) {
      return;
    }
    /* eslint-disable no-sync */


    fse.ensureDirSync(path.join(this.tmpDir, 'files'));
    fse.ensureDirSync(path.join(this.tmpDir, 'images'));
    /* eslint-enable no-sync */

    this.assetDirsCreated = true;
  }

  getAssetRequestOptions(assetDoc) {
    var token = this.client.config().token;
    var headers = {
      'User-Agent': `${pkg.name}@${pkg.version}`
    };
    var isImage = assetDoc._type === 'sanity.imageAsset';
    var url = parseUrl(assetDoc.url, true);

    if (isImage && ['cdn.sanity.io', 'cdn.sanity.work'].includes(url.hostname)) {
      headers.Authorization = `Bearer ${token}`;
      url.query = _objectSpread({}, url.query || {}, {
        dlRaw: 'true'
      });
    }

    return {
      url: formatUrl(url),
      headers
    };
  }

  downloadAsset(assetDoc, dstPath) {
    var _this2 = this,
        _arguments = arguments;

    return _asyncToGenerator(function* () {
      var attemptNum = _arguments.length > 2 && _arguments[2] !== undefined ? _arguments[2] : 0;
      var url = assetDoc.url;

      var options = _this2.getAssetRequestOptions(assetDoc);

      var stream = yield requestStream(options);

      if (stream.statusCode !== 200) {
        _this2.queue.clear();

        var err = yield tryGetErrorFromStream(stream);
        var errMsg = `Referenced asset URL "${url}" returned HTTP ${stream.statusCode}`;

        if (err) {
          errMsg = `${errMsg}:\n\n${err}`;
        }

        _this2.reject(new Error(errMsg));

        return false;
      }

      _this2.maybeCreateAssetDirs();

      debug('Asset stream ready, writing to filesystem at %s', dstPath);
      var tmpPath = path.join(_this2.tmpDir, dstPath);

      var _ref5 = yield writeHashedStream(tmpPath, stream),
          sha1 = _ref5.sha1,
          md5 = _ref5.md5; // If we have an ETag, it should be the md5 sum of the image
      // Verify it against our downloaded stream to make sure we have the same copy


      var remoteSha1 = stream.headers['x-sanity-sha1'];
      var etag = stream.headers.etag;
      var method = etag ? 'md5' : 'sha1';
      var differs = false;

      if (etag) {
        differs = etag !== md5;
      } else if (remoteSha1) {
        differs = remoteSha1 !== sha1;
      }

      if (differs && attemptNum < 3) {
        debug('%s does not match downloaded asset, retrying (#%d)', method, attemptNum + 1);
        return _this2.downloadAsset(assetDoc, dstPath, attemptNum + 1);
      } else if (differs) {
        yield fse.unlink(tmpPath);

        _this2.queue.clear();

        _this2.reject(new Error(`Failed to download image at ${assetDoc.url} after 3 attempts, giving up`));

        return false;
      }

      var isImage = assetDoc._type === 'sanity.imageAsset';
      var type = isImage ? 'image' : 'file';
      var id = `${type}-${sha1}`;
      var metaProps = omit(assetDoc, EXCLUDE_PROPS);

      if (Object.keys(metaProps).length > 0) {
        _this2.assetMap[id] = metaProps;
      }

      _this2.filesWritten++;
      return true;
    })();
  } // eslint-disable-next-line complexity


}

function isAssetField(item) {
  return item.asset && item.asset._ref;
}

function getAssetType(item) {
  if (!item.asset || typeof item.asset._ref !== 'string') {
    return null;
  }

  var _ref6 = item.asset._ref.match(/^(image|file)-/) || [],
      _ref7 = _slicedToArray(_ref6, 2),
      type = _ref7[1];

  return type || null;
}

function isModernAsset(assetId) {
  return /^(image|file)/.test(assetId);
}

function generateFilename(assetId) {
  var _ref8 = assetId.match(/^(image|file)-(.*?)(-[a-z]+)?$/) || [],
      _ref9 = _slicedToArray(_ref8, 4),
      asset = _ref9[2],
      ext = _ref9[3];

  var extension = (ext || 'bin').replace(/^-/, '');
  return asset ? `${asset}.${extension}` : `${assetId}.bin`;
}

function writeHashedStream(filePath, stream) {
  var md5 = crypto.createHash('md5');
  var sha1 = crypto.createHash('sha1');
  var hasher = miss.through((chunk, enc, cb) => {
    md5.update(chunk);
    sha1.update(chunk);
    cb(null, chunk);
  });
  return new Promise((resolve, reject) => miss.pipe(stream, hasher, fse.createWriteStream(filePath), err => err ? reject(err) : resolve({
    sha1: sha1.digest('hex'),
    md5: md5.digest('hex')
  })));
}

function tryGetErrorFromStream(stream) {
  return new Promise((resolve, reject) => {
    miss.pipe(stream, miss.concat(parse), err => err ? reject(err) : noop);

    function parse(body) {
      try {
        var parsed = JSON.parse(body.toString('utf8'));
        resolve(parsed.message || parsed.error || null);
      } catch (err) {
        resolve(body.toString('utf8').slice(0, 16000));
      }
    }
  });
}

module.exports = AssetHandler;