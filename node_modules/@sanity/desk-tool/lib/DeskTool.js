"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _shallowEquals = _interopRequireDefault(require("shallow-equals"));

var _client = _interopRequireDefault(require("part:@sanity/base/client"));

var _router = require("part:@sanity/base/router");

var _resolvePanes = require("./utils/resolvePanes");

var _DeskTool = _interopRequireDefault(require("./styles/DeskTool.css"));

var _DeskToolPanes = _interopRequireDefault(require("./DeskToolPanes"));

var _StructureError = _interopRequireDefault(require("./components/StructureError"));

var _serializeStructure = _interopRequireDefault(require("./utils/serializeStructure"));

var _defaultStructure = _interopRequireDefault(require("./defaultStructure"));

var _class, _temp;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var EMPTY_PANE_KEYS = [];

var hasLoading = panes => panes.some(item => item === _resolvePanes.LOADING);

var isStructure = structure => {
  return structure && (typeof structure === 'function' || typeof structure.serialize !== 'function' || typeof structure.then !== 'function' || typeof structure.subscribe !== 'function' || typeof structure.type !== 'string');
};

var prevStructureError = null;

if (__DEV__) {
  if (module.hot && module.hot.data) {
    prevStructureError = module.hot.data.prevError;
  }
} // We are lazy-requiring/resolving the structure inside of a function in order to catch errors
// on the root-level of the module. Any loading errors will be caught and emitted as errors
// eslint-disable-next-line complexity


var loadStructure = () => {
  var structure;

  try {
    var mod = require('part:@sanity/desk-tool/structure?') || _defaultStructure.default;

    structure = mod && mod.__esModule ? mod.default : mod; // On invalid modules, when HMR kicks in, we sometimes get an empty object back when the
    // source has changed without fixing the problem. In this case, keep showing the error

    if (__DEV__ && prevStructureError && structure && structure.constructor.name === 'Object' && Object.keys(structure).length === 0) {
      return (0, _rxjs.throwError)(prevStructureError);
    }

    prevStructureError = null;
  } catch (err) {
    prevStructureError = err;
    return (0, _rxjs.throwError)(err);
  }

  if (!isStructure(structure)) {
    return (0, _rxjs.throwError)(new Error("Structure needs to export a function, an observable, a promise or a stucture builder, got ".concat(typeof structure)));
  } // Defer to catch immediately thrown errors on serialization


  return (0, _rxjs.defer)(() => (0, _serializeStructure.default)(structure));
};

var maybeSerialize = structure => structure && typeof structure.serialize === 'function' ? structure.serialize({
  path: []
}) : structure;

var _default = (0, _router.withRouterHOC)(( // eslint-disable-next-line react/prefer-stateless-function
_temp = _class = class DeskTool extends _react.default.Component {
  constructor(_props) {
    super(_props);

    _defineProperty(this, "state", {
      isResolving: true,
      panes: null
    });

    _defineProperty(this, "maybeAddEditorPane", (panes, props) => {
      var router = props.router;
      var _router$state = router.state,
          editDocumentId = _router$state.editDocumentId,
          type = _router$state.type;

      if (!editDocumentId) {
        return (0, _rxjs.of)(panes);
      }

      var editor = {
        id: 'editor',
        type: 'document',
        options: {
          id: editDocumentId,
          type
        }
      };

      if (type !== '*') {
        return (0, _rxjs.of)(panes.concat(editor));
      }

      return (0, _rxjs.of)(panes.concat(_resolvePanes.LOADING)).pipe((0, _operators.concat)(_client.default.observable.fetch('*[_id == $id][0]._type', {
        id: editDocumentId
      }).pipe((0, _operators.map)(typeName => {
        router.navigate(_objectSpread({}, router.state, {
          type: typeName
        }), {
          replace: true
        });
        return panes.concat(_objectSpread({}, editor, {
          options: _objectSpread({}, editor.options, {
            type: typeName
          })
        }));
      }))));
    });

    _defineProperty(this, "setResolvedPanes", panes => {
      var router = this.props.router;
      var paneIds = router.state.panes || [];
      this.setState({
        panes,
        isResolving: false
      });

      if (panes.length < paneIds.length) {
        router.navigate(_objectSpread({}, router.state, {
          panes: paneIds.slice(0, panes.length)
        }), {
          replace: true
        });
      }
    });

    _defineProperty(this, "setResolveError", error => {
      prevStructureError = error; // Log error for proper stacktraces

      console.error(error); // eslint-disable-line no-console

      this.setState({
        error,
        isResolving: false
      });
    });

    _defineProperty(this, "shouldDerivePanes", nextProps => {
      var nextRouterState = nextProps.router.state;
      var prevRouterState = this.props.router.state;
      return !(0, _shallowEquals.default)(nextRouterState.panes, prevRouterState.panes) || nextRouterState.editDocumentId !== prevRouterState.editDocumentId || nextRouterState.legacyEditDocumentId !== prevRouterState.legacyEditDocumentId || nextRouterState.type !== prevRouterState.type || nextRouterState.action !== prevRouterState.action;
    });

    _props.onPaneChange([]);
  }

  derivePanes(props) {
    var fromIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

    if (this.paneDeriver) {
      this.paneDeriver.unsubscribe();
    }

    this.setState({
      isResolving: true
    });
    this.paneDeriver = loadStructure().pipe((0, _operators.distinctUntilChanged)(), (0, _operators.map)(maybeSerialize), (0, _operators.switchMap)(structure => (0, _resolvePanes.resolvePanes)(structure, props.router.state.panes || [], this.state.panes, fromIndex)), (0, _operators.switchMap)(panes => this.maybeAddEditorPane(panes, props)), (0, _operators.debounce)(panes => (0, _rxjs.interval)(hasLoading(panes) ? 50 : 0))).subscribe(this.setResolvedPanes, this.setResolveError);
  }

  // @todo move this out of cWRP - it's deprecated
  // eslint-disable-next-line camelcase
  UNSAFE_componentWillReceiveProps(nextProps) {
    if (this.shouldDerivePanes(nextProps)) {
      var prevPanes = this.props.router.state.panes || [];
      var nextPanes = nextProps.router.state.panes || [];
      var diffAt = nextPanes.findIndex((id, index) => prevPanes[index] !== id);
      this.derivePanes(nextProps, diffAt === -1 ? 0 : diffAt);
    }
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevProps.onPaneChange !== this.props.onPaneChange || prevState.panes !== this.state.panes) {
      this.props.onPaneChange(this.state.panes || []);
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    if (this.shouldDerivePanes(nextProps)) {
      return false;
    }

    var _this$props = this.props,
        oldRouter = _this$props.router,
        oldProps = _objectWithoutProperties(_this$props, ["router"]);

    var newRouter = nextProps.router,
        newProps = _objectWithoutProperties(nextProps, ["router"]);

    var _this$state = this.state,
        oldPanes = _this$state.panes,
        oldState = _objectWithoutProperties(_this$state, ["panes"]);

    var newPanes = nextState.panes,
        newState = _objectWithoutProperties(nextState, ["panes"]);

    return !(0, _shallowEquals.default)(oldProps, newProps) || !(0, _shallowEquals.default)(oldPanes, newPanes) || !(0, _shallowEquals.default)(oldState, newState);
  }

  maybeHandleOldUrl() {
    var navigate = this.props.router.navigate;
    var _this$props$router$st = this.props.router.state,
        panes = _this$props$router$st.panes,
        action = _this$props$router$st.action,
        legacyEditDocumentId = _this$props$router$st.legacyEditDocumentId;

    if (action === 'edit' && legacyEditDocumentId) {
      navigate({
        panes: panes.concat([legacyEditDocumentId])
      }, {
        replace: true
      });
    }
  }

  componentDidMount() {
    this.maybeHandleOldUrl();
    this.derivePanes(this.props);
    this.props.onPaneChange(this.state.panes || []);
  }

  componentWillUnmount() {
    if (this.paneDeriver) {
      this.paneDeriver.unsubscribe();
    }
  }

  getFallbackKeys() {
    var routerState = this.props.router.state;
    return routerState.type && routerState.editDocumentId ? ["".concat(routerState.type, "-").concat(routerState.editDocumentId)] : EMPTY_PANE_KEYS;
  }

  render() {
    var _this$state2 = this.state,
        panes = _this$state2.panes,
        error = _this$state2.error;

    if (error) {
      return _react.default.createElement(_StructureError.default, {
        error: error
      });
    }

    var keys = this.props.router.state.panes || this.getFallbackKeys();
    return _react.default.createElement("div", {
      className: _DeskTool.default.deskTool
    }, panes && _react.default.createElement(_DeskToolPanes.default, {
      panes: this.state.panes,
      keys: keys,
      autoCollapse: true
    }));
  }

}, _defineProperty(_class, "propTypes", {
  router: _propTypes.default.shape({
    navigate: _propTypes.default.func.isRequired,
    state: _propTypes.default.shape({
      panes: _propTypes.default.arrayOf(_propTypes.default.string),
      editDocumentId: _propTypes.default.string,
      legacyEditDocumentId: _propTypes.default.string,
      type: _propTypes.default.string,
      action: _propTypes.default.string
    })
  }).isRequired,
  onPaneChange: _propTypes.default.func.isRequired
}), _temp));

exports.default = _default;

if (__DEV__) {
  if (module.hot) {
    module.hot.dispose(data => {
      data.prevError = prevStructureError;
    });
  }
}