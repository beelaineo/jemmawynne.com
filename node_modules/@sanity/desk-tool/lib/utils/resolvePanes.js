"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.resolvePanes = resolvePanes;
exports.LOADING = void 0;

var _shallowEquals = _interopRequireDefault(require("shallow-equals"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _generateHelpUrl = _interopRequireDefault(require("@sanity/generate-help-url"));

var _isSubscribable = _interopRequireDefault(require("./isSubscribable"));

var _validateStructure = _interopRequireDefault(require("./validateStructure"));

var _serializeStructure = _interopRequireDefault(require("./serializeStructure"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var LOADING = Symbol('LOADING');
exports.LOADING = LOADING;

function resolvePanes(structure, ids, prevStructure, fromIndex) {
  var waitStructure = (0, _isSubscribable.default)(structure) ? (0, _rxjs.from)(structure) : (0, _rxjs.of)(structure);
  return waitStructure.pipe((0, _operators.switchMap)(struct => resolveForStructure(struct, ids, prevStructure, fromIndex)));
}

function getInitialPanes(prevStructure, numPanes, fromIndex) {
  var allLoading = new Array(numPanes).fill(LOADING);

  if (!prevStructure) {
    return allLoading;
  }

  var remains = prevStructure.slice(0, fromIndex);
  return remains.concat(allLoading.slice(fromIndex));
}

function resolveForStructure(structure, ids, prevStructure, fromIndex) {
  return _rxjs.Observable.create(subscriber => {
    try {
      (0, _validateStructure.default)(structure);
    } catch (err) {
      subscriber.error(err);
      return unsubscribe;
    }

    var paneIds = [structure.id].concat(ids).filter(Boolean);
    var panes = getInitialPanes(prevStructure, paneIds.length, fromIndex + 1);
    var subscriptions = []; // Start with all-loading (or previous structure) state

    subscriber.next(panes); // Start resolving pane-by-pane

    resolve(Math.max(0, panes.indexOf(LOADING)));
    return unsubscribe;

    function resolve(index) {
      if (index > paneIds.length - 1) {
        return;
      }

      var id = paneIds[index];
      var parent = panes[index - 1];
      var context = {
        parent,
        index,
        path: paneIds.slice(0, index + 1)
      };

      if (index === 0) {
        subscribeForUpdates(structure, index, context);
        return;
      }

      if (!parent || !parent.child) {
        subscriber.complete();
        return;
      }

      subscribeForUpdates(parent.child, index, context, [id, context]);
    }

    function subscribeForUpdates(pane, index, context, resolverArgs) {
      var source = (0, _serializeStructure.default)(pane, context, resolverArgs);
      subscriptions.push(source.subscribe(result => emit(result, index), error => subscriber.error(error)));
    }

    function emit(pane, index) {
      if (typeof pane === 'undefined') {
        // eslint-disable-next-line no-console
        console.warn('Pane at index %d returned no child - see %s', index, (0, _generateHelpUrl.default)('structure-item-returned-no-child'));
      }

      if (replacePane(pane, index)) {
        subscriber.next(panes); // eslint-disable-line callback-return
      }

      resolve(index + 1);
    }

    function replacePane(pane, index) {
      if (panes[index] === pane || (0, _shallowEquals.default)(panes[index], pane)) {
        return undefined;
      }

      panes = panes.slice();
      return pane ? panes.splice(index, 1, pane) : panes.splice(index);
    }

    function unsubscribe() {
      while (subscriptions.length) {
        subscriptions.pop().unsubscribe();
      }
    }
  });
}