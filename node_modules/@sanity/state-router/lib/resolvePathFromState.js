"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = resolvePathFromState;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _findMatchingNodes = _interopRequireDefault(require("./findMatchingNodes"));

var _debug = require("./utils/debug");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function resolvePathFromState(node, state) {
  (0, _debug.debug)('Resolving path from state %o', state);
  const match = (0, _findMatchingNodes.default)(node, state);

  if (match.remaining.length > 0) {
    const remaining = match.remaining;
    throw new Error(`Unable to find matching route for state. Could not map the following state key${remaining.length == 1 ? '' : 's'} to a valid url: ${remaining.join(', ')}`);
  }

  if (match.nodes.length === 0) {
    throw new Error(`Unable to resolve path from given state: ${JSON.stringify(state)}`);
  }

  let scopedState = state;
  const relative = (0, _flatten2.default)(match.nodes.map(matchNode => {
    if (matchNode.scope) {
      scopedState = scopedState[matchNode.scope];
    }

    return matchNode.route.segments.map(segment => {
      if (segment.type === 'dir') {
        return segment.name;
      }

      const transform = matchNode.transform && matchNode.transform[segment.name];
      return transform ? transform.toPath(scopedState[segment.name]) : scopedState[segment.name];
    });
  })).join('/');
  (0, _debug.debug)('Resolved to /%s', relative);
  return `/${relative}`;
}