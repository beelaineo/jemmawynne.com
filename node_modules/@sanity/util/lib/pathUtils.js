"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.get = get;
exports.isEqual = isEqual;
exports.isSegmentEqual = isSegmentEqual;
exports.hasFocus = hasFocus;
exports.hasItemFocus = hasItemFocus;
exports.isExpanded = isExpanded;
exports.startsWith = startsWith;
exports.trimLeft = trimLeft;
exports.trimRight = trimRight;
exports.toString = toString;
exports.fromString = fromString;
exports.FOCUS_TERMINATOR = void 0;

function _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter); }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

/* eslint-disable max-depth */
var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
var reKeySegment = /_key\s*==\s*['"](.*)['"]/;
var FOCUS_TERMINATOR = '$'; // eslint-disable-next-line complexity

exports.FOCUS_TERMINATOR = FOCUS_TERMINATOR;

function get(obj, path, defaultVal) {
  var select = typeof path === 'string' ? fromString(path) : path;

  if (!Array.isArray(select)) {
    throw new Error('Path must be an array or a string');
  }

  var acc = obj;

  var _loop = function _loop(i) {
    var segment = select[i];

    if (isIndexSegment(segment)) {
      if (!Array.isArray(acc)) {
        return {
          v: defaultVal
        };
      }

      acc = acc[segment];
    }

    if (isKeySegment(segment)) {
      if (!Array.isArray(acc)) {
        return {
          v: defaultVal
        };
      }

      acc = acc.find(item => item._key === segment._key);
    }

    if (typeof segment === 'string') {
      acc = typeof acc === 'object' && acc !== null ? acc[segment] : undefined;
    }

    if (typeof acc === 'undefined') {
      return {
        v: defaultVal
      };
    }
  };

  for (var i = 0; i < select.length; i++) {
    var _ret = _loop(i);

    if (typeof _ret === "object") return _ret.v;
  }

  return acc;
}

function isEqual(path, otherPath) {
  return path.length === otherPath.length && path.every((segment, i) => isSegmentEqual(segment, otherPath[i]));
}

function isSegmentEqual(pathSegment, otherPathSegment) {
  var pathSegmentType = typeof pathSegment;
  var otherPathSegmentType = typeof otherPathSegment;

  if (pathSegmentType !== otherPathSegmentType) {
    return false;
  }

  if (pathSegmentType === 'string' || pathSegmentType === 'number') {
    return pathSegment === otherPathSegment;
  }

  if (!pathSegment || !otherPathSegment) {
    return false;
  }

  return pathSegment._key === otherPathSegment._key;
}

function hasFocus(focusPath, path) {
  var _withoutFirst = focusPath[focusPath.length - 1] === FOCUS_TERMINATOR ? focusPath.slice(0, -1) : focusPath;

  return isEqual(_withoutFirst, path);
}

function hasItemFocus(focusPath, item) {
  return focusPath.length === 1 && isSegmentEqual(focusPath[0], item);
}

function isExpanded(segment, focusPath) {
  var _focusPath = _toArray(focusPath),
      head = _focusPath[0],
      tail = _focusPath.slice(1);

  return tail.length > 0 && isSegmentEqual(segment, head);
}

function startsWith(prefix, path) {
  return prefix.every((segment, i) => isSegmentEqual(segment, path[i]));
}

function trimLeft(prefix, path) {
  if (prefix.length === 0 || path.length === 0) {
    return path;
  }

  var _prefix = _toArray(prefix),
      prefixHead = _prefix[0],
      prefixTail = _prefix.slice(1);

  var _path = _toArray(path),
      pathHead = _path[0],
      pathTail = _path.slice(1);

  if (!isSegmentEqual(prefixHead, pathHead)) {
    return path;
  }

  return trimLeft(prefixTail, pathTail);
}

function trimRight(suffix, path) {
  var sufLen = suffix.length;
  var pathLen = path.length;

  if (sufLen === 0 || pathLen === 0) {
    return path;
  }

  var i = 0;

  while (i < sufLen && i < pathLen && isSegmentEqual(path[pathLen - i - 1], suffix[sufLen - i - 1])) {
    i++;
  }

  return path.slice(0, pathLen - i);
}

function toString(path) {
  if (!Array.isArray(path)) {
    throw new Error('Path is not an array');
  }

  return path.reduce((target, segment, i) => {
    var segmentType = typeof segment;

    if (segmentType === 'number') {
      return `${target}[${segment}]`;
    }

    if (segmentType === 'string') {
      var separator = i === 0 ? '' : '.';
      return `${target}${separator}${segment}`;
    }

    if (segment._key) {
      return `${target}[_key=="${segment._key}"]`;
    }

    throw new Error(`Unsupported path segment \`${JSON.stringify(segment)}\``);
  }, '');
}

function fromString(path) {
  if (typeof path !== 'string') {
    throw new Error('Path is not a string');
  }

  var segments = path.match(rePropName);

  if (!segments) {
    throw new Error('Invalid path string');
  }

  return segments.map(normalizePathSegment);
}

function normalizePathSegment(segment) {
  if (isIndexSegment(segment)) {
    return normalizeIndexSegment(segment);
  }

  if (isKeySegment(segment)) {
    return normalizeKeySegment(segment);
  }

  return segment;
}

function normalizeIndexSegment(segment) {
  return Number(segment.replace(/[^\d]/g, ''));
}

function normalizeKeySegment(segment) {
  var segments = segment.match(reKeySegment);
  return {
    _key: segments[1]
  };
}

function isIndexSegment(segment) {
  return typeof segment === 'number' || /^\[\d+\]$/.test(segment);
}

function isKeySegment(segment) {
  if (typeof segment === 'string') {
    return reKeySegment.test(segment.trim());
  }

  return segment && segment._key;
}