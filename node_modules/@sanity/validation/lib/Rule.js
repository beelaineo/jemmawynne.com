"use strict";

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var cloneDeep = require('clone-deep');

var escapeRegex = require('./util/escapeRegex');

var validate = require('./validate');

var knownTypes = ['Object', 'String', 'Number', 'Boolean', 'Array', 'Date'];
var isExclusive = ['type', 'uri', 'email'];

var mergeRequired = (prev, next) => {
  var isRequired = prev._required || next._required;

  if (!isRequired) {
    isRequired = prev._required === false || next._required === false ? false : undefined;
  }

  return isRequired;
};

class Rule {
  constructor(typeDef) {
    this.FIELD_REF = Rule.FIELD_REF;
    this._typeDef = typeDef;
    this.reset();
  } // Alias to static method, since we often have access to an _instance_ of a rule but not the actual Rule class
  // eslint-disable-next-line class-methods-use-this


  valueOfField() {
    return Rule.valueOfField(...arguments);
  }

  error(message) {
    var rule = this.clone();
    rule._level = 'error';
    rule._message = message || null;
    return rule;
  }

  warning(message) {
    var rule = this.clone();
    rule._level = 'warning';
    rule._message = message || null;
    return rule;
  }

  reset() {
    this._type = this._type || null;
    this._rules = (this._rules || []).filter(rule => rule.flag === 'type');
    this._message = null;
    this._required = undefined;
    this._level = 'error';
    this._fieldRules = undefined;
    return this;
  }

  isRequired() {
    return this._required === true;
  }

  clone() {
    var rule = new Rule();
    rule._type = this._type;
    rule._message = this._message;
    rule._required = this._required;
    rule._rules = cloneDeep(this._rules);
    rule._level = this._level;
    rule._fieldRules = this._fieldRules;
    rule._typeDef = this._typeDef;
    return rule;
  }

  cloneWithRules(rules) {
    var rule = this.clone();
    var newRules = new Set();
    rules.forEach(curr => {
      if (curr.flag === 'type') {
        rule._type = curr.constraint;
      }

      newRules.add(curr.flag);
    });
    rule._rules = rule._rules.filter(curr => {
      var disallowDuplicate = isExclusive.includes(curr.flag);
      var isDuplicate = newRules.has(curr.flag);
      return !(disallowDuplicate && isDuplicate);
    }).concat(rules);
    return rule;
  }

  merge(rule) {
    if (this._type && rule._type && this._type !== rule._type) {
      throw new Error('merge() failed: conflicting types');
    }

    var newRule = this.cloneWithRules(rule._rules);
    newRule._type = this._type || rule._type;
    newRule._message = this._message || rule._message;
    newRule._required = mergeRequired(this, rule);
    newRule._level = this._level === 'error' ? rule._level : this._level;
    return newRule;
  }

  validate(value) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    return validate(this, value, options);
  } // Validation flag setters


  type(targetType) {
    var type = "".concat(targetType.slice(0, 1).toUpperCase()).concat(targetType.slice(1));

    if (!knownTypes.includes(type)) {
      throw new Error("Unknown type \"".concat(targetType, "\""));
    }

    var rule = this.cloneWithRules([{
      flag: 'type',
      constraint: type
    }]);
    rule._type = type;
    return rule;
  }

  all(children) {
    return this.cloneWithRules([{
      flag: 'all',
      constraint: children
    }]);
  }

  either(children) {
    return this.cloneWithRules([{
      flag: 'either',
      constraint: children
    }]);
  } // Shared rules


  optional() {
    var rule = this.cloneWithRules([{
      flag: 'presence',
      constraint: 'optional'
    }]);
    rule._required = false;
    return rule;
  }

  required() {
    var rule = this.cloneWithRules([{
      flag: 'presence',
      constraint: 'required'
    }]);
    rule._required = true;
    return rule;
  }

  custom(fn) {
    return this.cloneWithRules([{
      flag: 'custom',
      constraint: fn
    }]);
  }

  min(len) {
    return this.cloneWithRules([{
      flag: 'min',
      constraint: len
    }]);
  }

  max(len) {
    return this.cloneWithRules([{
      flag: 'max',
      constraint: len
    }]);
  }

  length(len) {
    return this.cloneWithRules([{
      flag: 'length',
      constraint: len
    }]);
  }

  valid(value) {
    var values = Array.isArray(value) ? value : [value];
    return this.cloneWithRules([{
      flag: 'valid',
      constraint: values
    }]);
  } // Numbers only


  integer() {
    return this.cloneWithRules([{
      flag: 'integer'
    }]);
  }

  precision(limit) {
    return this.cloneWithRules([{
      flag: 'precision',
      constraint: limit
    }]);
  }

  positive() {
    return this.cloneWithRules([{
      flag: 'min',
      constraint: 0
    }]);
  }

  negative() {
    return this.cloneWithRules([{
      flag: 'lessThan',
      constraint: 0
    }]);
  }

  greaterThan(num) {
    return this.cloneWithRules([{
      flag: 'greaterThan',
      constraint: num
    }]);
  }

  lessThan(num) {
    return this.cloneWithRules([{
      flag: 'lessThan',
      constraint: num
    }]);
  } // String only


  uppercase() {
    return this.cloneWithRules([{
      flag: 'stringCasing',
      constraint: 'uppercase'
    }]);
  }

  lowercase() {
    return this.cloneWithRules([{
      flag: 'stringCasing',
      constraint: 'lowercase'
    }]);
  }

  regex(pattern, name, opts) {
    var options = opts || {
      name
    };

    if (!opts && name && (name.name || name.invert)) {
      options = name;
    }

    var constraint = Object.assign({}, options, {
      pattern
    });
    return this.cloneWithRules([{
      flag: 'regex',
      constraint
    }]);
  }

  email(options) {
    return this.cloneWithRules([{
      flag: 'email',
      constraint: options
    }]);
  }

  uri() {
    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var options = Object.assign({
      scheme: ['http', 'https'],
      allowRelative: false,
      relativeOnly: false
    }, opts);
    var allowedSchemes = Array.isArray(options.scheme) ? options.scheme : [options.scheme];
    options.scheme = allowedSchemes.map(scheme => {
      var schemeIsString = typeof scheme === 'string';

      if (!(scheme instanceof RegExp) && schemeIsString === false) {
        throw new Error('scheme must be a RegExp or a String');
      }

      return schemeIsString ? new RegExp("^".concat(escapeRegex(scheme), "$")) : scheme;
    });

    if (!options.scheme.length) {
      throw new Error('scheme must have at least 1 scheme specified');
    }

    return this.cloneWithRules([{
      flag: 'uri',
      constraint: {
        options
      }
    }]);
  } // Array only


  unique(comparator) {
    return this.cloneWithRules([{
      flag: 'unique',
      constraint: comparator
    }]);
  } // Objects only


  reference() {
    return this.cloneWithRules([{
      flag: 'reference'
    }]);
  }

  fields(rules) {
    if (this._type !== 'Object') {
      throw new Error('fields() can only be called on an object type');
    }

    var rule = this.cloneWithRules([]);
    rule._fieldRules = rules;
    return rule;
  }

  assetRequired() {
    var base = getBaseType(this._typeDef);
    var assetType = 'Asset';

    if (base && ['image', 'file'].includes(base.name)) {
      assetType = base.name === 'image' ? 'Image' : 'File';
    }

    return this.cloneWithRules([{
      flag: 'assetRequired',
      constraint: {
        assetType
      }
    }]);
  }

}

_defineProperty(Rule, "FIELD_REF", Symbol('FIELD_REF'));

_defineProperty(Rule, "array", def => new Rule(def).type('Array'));

_defineProperty(Rule, "object", def => new Rule(def).type('Object'));

_defineProperty(Rule, "string", def => new Rule(def).type('String'));

_defineProperty(Rule, "number", def => new Rule(def).type('Number'));

_defineProperty(Rule, "boolean", def => new Rule(def).type('Boolean'));

_defineProperty(Rule, "dateTime", def => new Rule(def).type('Date'));

_defineProperty(Rule, "valueOfField", path => ({
  type: Rule.FIELD_REF,
  path
}));

function getBaseType(type) {
  return type && type.type ? getBaseType(type.type) : type;
}

module.exports = Rule;