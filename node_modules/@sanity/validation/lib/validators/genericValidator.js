"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

var Type = require('type-of-is');

var _require = require('lodash'),
    flatten = _require.flatten;

var deepEquals = require('../util/deepEquals');

var pathToString = require('../util/pathToString');

var ValidationError = require('../ValidationError');

var SLOW_VALIDATOR_TIMEOUT = 5000;

var type = (expected, value, message) => {
  var actualType = Type.string(value);

  if (actualType !== expected && actualType !== 'undefined') {
    return new ValidationError(message || "Expected type \"".concat(expected, "\", got \"").concat(actualType, "\""));
  }

  return true;
};

var presence = (expected, value, message) => {
  if (typeof value === 'undefined' && expected === 'required') {
    return new ValidationError(message || 'Value is required');
  }

  return true;
};

var multiple = (children, value) => {
  var validate = require('../validate');

  var items = children.map(child => validate(child, value, {
    isChild: true
  }));
  return Promise.all(items).then(flatten);
};

var all = (children, value, message) => multiple(children, value).then(results => {
  var numErrors = results.length;
  return numErrors === 0 ? true : formatValidationErrors(message, results, {
    separator: ' - AND - ',
    operator: 'AND'
  });
});

var either = (children, value, message) => multiple(children, value).then(results => {
  var numErrors = results.length; // Read: There is at least one rule that matched

  return numErrors < children.length ? true : formatValidationErrors(message, results, {
    separator: ' - OR - ',
    operator: 'OR'
  });
});

var valid = (allowedValues, actual, message) => {
  var valueType = typeof actual;

  if (valueType === 'undefined') {
    return true;
  }

  var value = (valueType === 'number' || valueType === 'string') && "".concat(actual);
  var strValue = value && value.length > 30 ? "".concat(value.slice(0, 30), "\u2026") : value;
  var defaultMessage = value ? "Value \"".concat(strValue, "\" did not match any of allowed values") : 'Value did not match any of allowed values';
  return allowedValues.some(expected => deepEquals(expected, actual)) ? true : new ValidationError(message || defaultMessage);
};

var custom =
/*#__PURE__*/
function () {
  var _ref = _asyncToGenerator(function* (fn, value, message, options) {
    var slowTimer = setTimeout(() => {
      var path = pathToString(options.path); // eslint-disable-next-line no-console

      console.warn("Custom validator at ".concat(path, " has taken more than ").concat(SLOW_VALIDATOR_TIMEOUT, "ms to respond"));
    }, SLOW_VALIDATOR_TIMEOUT);
    var result;

    try {
      result = yield fn(value, options);
    } catch (err) {
      var _path = pathToString(options.path);

      err.message = "".concat(_path, ": Error validating value: ").concat(err.message);
      throw err;
    }

    clearTimeout(slowTimer);

    if (Array.isArray(result)) {
      if (result.length === 0) {
        return true;
      }

      return result;
    }

    if (result === true) {
      return true;
    }

    if (typeof result === 'string') {
      return new ValidationError(message || result);
    }

    if (result && result.message && result.paths) {
      return new ValidationError(message || result.message, {
        paths: result.paths
      });
    }

    var path = pathToString(options.path);
    throw new Error("".concat(path, ": Validator must return 'true' if valid or an error message as a string on errors"));
  });

  return function custom(_x, _x2, _x3, _x4) {
    return _ref.apply(this, arguments);
  };
}();

function formatValidationErrors(message, results) {
  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var errOpts = {
    children: results.length > 1 ? results : undefined,
    operator: options.operator
  };
  return results.length === 1 ? new ValidationError(message || results[0].item.message, errOpts) : new ValidationError(message || "[".concat(results.map(err => err.item.message).join(options.separator), "]"), errOpts);
}

module.exports = {
  all,
  type,
  either,
  valid,
  custom,
  presence
};