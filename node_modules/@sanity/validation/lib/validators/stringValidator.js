"use strict";

var ValidationError = require('../ValidationError');

var genericValidator = require('./genericValidator');

var DUMMY_ORIGIN = 'http://sanity';
var emailRegex = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;

var isRelativeUrl = url => /^\.*\//.test(url);

var min = (minLength, value, message) => {
  if (!value || value.length >= minLength) {
    return true;
  }

  return new ValidationError(message || "Must be at least ".concat(minLength, " characters long"));
};

var max = (maxLength, value, message) => {
  if (!value || value.length <= maxLength) {
    return true;
  }

  return new ValidationError(message || "Must be at most ".concat(maxLength, " characters long"));
};

var length = (wantedLength, value, message) => {
  var strValue = value || '';

  if (strValue.length === wantedLength) {
    return true;
  }

  return new ValidationError(message || "Must be exactly ".concat(wantedLength, " characters long"));
}; // eslint-disable-next-line complexity


var uri = (constraints, value, message) => {
  var strValue = value || '';
  var options = constraints.options;
  var allowCredentials = options.allowCredentials,
      relativeOnly = options.relativeOnly;
  var allowRelative = options.allowRelative || relativeOnly;
  var url;

  try {
    // WARNING: Safari checks for a given `base` param by looking at the length of arguments passed
    // to new URL(str, base), and will fail if invoked with new URL(strValue, undefined)
    url = allowRelative ? new URL(strValue, DUMMY_ORIGIN) : new URL(strValue);
  } catch (err) {
    return new ValidationError(message || 'Not a valid URL');
  }

  if (relativeOnly && url.origin !== DUMMY_ORIGIN) {
    return new ValidationError(message || 'Only relative URLs are allowed');
  }

  if (!allowRelative && url.origin === DUMMY_ORIGIN && isRelativeUrl(strValue)) {
    return new ValidationError(message || 'Relative URLs are not allowed');
  }

  if (!allowCredentials && (url.username || url.password)) {
    return new ValidationError(message || "Username/password not allowed");
  }

  var urlScheme = url.protocol.replace(/:$/, '');
  var matchesAllowedScheme = options.scheme.some(scheme => scheme.test(urlScheme));

  if (!matchesAllowedScheme) {
    return new ValidationError(message || 'Does not match allowed protocols/schemes');
  }

  return true;
};

var stringCasing = (casing, value, message) => {
  var strValue = value || '';

  if (casing === 'uppercase' && strValue !== strValue.toLocaleUpperCase()) {
    return new ValidationError(message || "Must be all uppercase letters");
  }

  if (casing === 'lowercase' && strValue !== strValue.toLocaleLowerCase()) {
    return new ValidationError(message || "Must be all lowercase letters");
  }

  return true;
};

var presence = (flag, value, message) => {
  if (flag === 'required' && !value) {
    return new ValidationError(message || 'Required');
  }

  return true;
};

var regex = (options, value, message) => {
  var pattern = options.pattern,
      name = options.name,
      invert = options.invert;
  var regName = name || "\"".concat(pattern.toString(), "\"");
  var strValue = value || '';
  var matches = pattern.test(strValue);

  if (!invert && !matches || invert && matches) {
    var defaultMessage = invert ? "Should not match ".concat(regName, "-pattern") : "Does not match ".concat(regName, "-pattern");
    return new ValidationError(message || defaultMessage);
  }

  return true;
};

var email = (options, value, message) => {
  var strValue = "".concat(value || '').trim();

  if (!strValue || emailRegex.test(strValue)) {
    return true;
  }

  return new ValidationError(message || 'Must be a valid email address');
};

module.exports = Object.assign({}, genericValidator, {
  stringCasing,
  presence,
  regex,
  length,
  email,
  min,
  max,
  uri
});