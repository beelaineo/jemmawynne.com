"use strict";

var deepEquals = require('../util/deepEquals');

var ValidationError = require('../ValidationError');

var genericValidator = require('./genericValidator');

var min = (minLength, value, message) => {
  if (!value || value.length >= minLength) {
    return true;
  }

  return new ValidationError(message || "Must have at least ".concat(minLength, " items"));
};

var max = (maxLength, value, message) => {
  if (!value || value.length <= maxLength) {
    return true;
  }

  return new ValidationError(message || "Must have at most ".concat(maxLength, " items"));
};

var length = (wantedLength, value, message) => {
  if (!value || value.length === wantedLength) {
    return true;
  }

  return new ValidationError(message || "Must have exactly ".concat(wantedLength, " items"));
};

var presence = (flag, value, message) => {
  if (flag === 'required' && !value) {
    return new ValidationError(message || 'Required');
  }

  return true;
};

var valid = (allowedValues, values, message) => {
  var valueType = typeof values;

  if (valueType === 'undefined') {
    return true;
  }

  var paths = [];

  var _loop = function _loop(i) {
    var value = values[i];

    if (allowedValues.some(expected => deepEquals(expected, value))) {
      return "continue";
    }

    var pathSegment = value && value._key ? {
      _key: value._key
    } : i;
    paths.push([pathSegment]);
  };

  for (var i = 0; i < values.length; i++) {
    var _ret = _loop(i);

    if (_ret === "continue") continue;
  }

  return paths.length === 0 ? true : new ValidationError(message || 'Value did not match any of allowed values', {
    paths
  });
};

var unique = (flag, value, message) => {
  var dupeIndices = [];

  if (!value) {
    return true;
  }
  /* eslint-disable max-depth */


  for (var x = 0; x < value.length; x++) {
    for (var y = x + 1; y < value.length; y++) {
      var itemA = value[x];
      var itemB = value[y];

      if (!deepEquals(itemA, itemB)) {
        continue;
      }

      if (dupeIndices.indexOf(x) === -1) {
        dupeIndices.push(x);
      }

      if (dupeIndices.indexOf(y) === -1) {
        dupeIndices.push(y);
      }
    }
  }
  /* eslint-enable max-depth */


  var paths = dupeIndices.map(idx => {
    var item = value[idx];
    var pathSegment = item && item._key ? {
      _key: item._key
    } : idx;
    return [pathSegment];
  });
  return dupeIndices.length > 0 ? new ValidationError(message || "Can't be a duplicate", {
    paths
  }) : true;
};

module.exports = Object.assign({}, genericValidator, {
  presence,
  unique,
  length,
  valid,
  min,
  max
});