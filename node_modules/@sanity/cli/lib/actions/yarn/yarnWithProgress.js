"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = yarnWithProgress;

var _throttle2 = _interopRequireDefault(require("lodash/throttle"));

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _path = _interopRequireDefault(require("path"));

var _ora = _interopRequireDefault(require("ora"));

var _execa = _interopRequireDefault(require("execa"));

var _split = _interopRequireDefault(require("split2"));

var _chalk = _interopRequireDefault(require("chalk"));

var _gauge = _interopRequireDefault(require("gauge"));

var _dynamicRequire = _interopRequireDefault(require("../../util/dynamicRequire"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-process-env */
const useProgress = process.stderr && process.stderr.isTTY && !process.env.CI;
const isBundled = typeof __SANITY_IS_BUNDLED__ !== 'undefined'; // Use require.resolve to ensure it actually exists in development mode

const binDir = _path.default.join(__dirname, '..', '..', '..', 'vendor');

const yarnPath = isBundled ? _path.default.join(__dirname, '..', 'vendor', 'yarn') : _dynamicRequire.default.resolve(_path.default.join(binDir, 'yarn'));

const parseJson = data => {
  try {
    return JSON.parse(data);
  } catch (err) {
    return undefined;
  }
};

function yarnWithProgress(args, options = {}) {
  /* eslint-disable no-console */
  const print = options.print || console.log;
  const error = options.error || console.error;
  /* eslint-enable no-console */

  const execOpts = Object.assign({
    cwd: options.rootDir || process.cwd(),
    env: {
      PATH: [binDir, process.env.PATH].join(_path.default.delimiter)
    }
  }, options.execOpts || {});
  const nodePath = process.argv[0];
  const nodeArgs = [yarnPath].concat(args, ['--json', '--non-interactive', '--ignore-engines', '--registry', 'https://registry.npmjs.org']);
  const state = {
    firstStepReceived: false,
    currentProgressStep: null
  };
  state.progress = new _gauge.default(process.stderr, {
    theme: 'colorASCII',
    enabled: true
  }); // Yarn takes a while before starting to emit events, we want to show
  // some sort of indication while it's getting started

  onStep({
    data: {
      message: 'Resolving dependencies'
    }
  });
  onActivityStart({});
  const proc = (0, _execa.default)(nodePath, nodeArgs, execOpts);
  proc.catch(onNativeError); // Will throw error async through the promise above

  if (!proc.stdout) {
    return proc;
  }

  const streams = [proc.stdout, proc.stderr];
  streams.forEach(stream => {
    stream.pipe((0, _split.default)(parseJson)).on('data', onChunk).on('error', onNativeError);
  });
  const interceptors = options.interceptors || {};
  const throttledOnProgressTick = (0, _throttle2.default)(onProgressTick, 50); // eslint-disable-next-line complexity

  function onChunk(event) {
    if (interceptors[event.type]) {
      return interceptors[event.type](event);
    }

    switch (event.type) {
      case 'error':
        return onError(event);

      case 'warning':
        return onWarning(event);

      case 'step':
        return onStep(event);

      case 'activityStart':
        return onActivityStart(event);

      case 'activityTick':
        return onActivityTick(event);

      case 'activitySetEnd':
      case 'activityEnd':
        return onActivityEnd(event);

      case 'progressStart':
        return onProgressStart(event);

      case 'progressTick':
        return throttledOnProgressTick(event);

      case 'progressFinish':
        return onProgressFinish(event);

      case 'success':
        return onSuccess(event);

      case 'finished':
        return onFinished(event);

      default:
        // console.log(event)
        return (0, _noop2.default)();
    }
  }

  function onActivityStart(event) {
    if (!state.step) {
      return;
    }

    if (!state.firstStepReceived && state.spinner) {
      state.firstStepReceived = true;
      onActivityEnd();
    }

    state.spinner = (0, _ora.default)(state.step.message).start();
  }

  function onActivityTick(event) {
    if (!state.spinner) {
      return;
    }

    state.spinner.text = `${state.step.message} (${event.data.name})`;
  }

  function onActivityEnd(event) {
    if (!state.spinner) {
      return;
    }

    state.spinner.text = state.step.message;
    state.spinner.succeed();
  }

  function onProgressStart(event) {
    // For some events (Linking dependencies, for instance), multiple progress
    // start events are emitted, which doesn't look great. Skip those.
    if (state.step.message === state.currentProgressStep) {
      return;
    }

    if (state.spinner) {
      state.spinner.stop();
    }

    if (useProgress && event.data.total) {
      state.currentProgressStep = state.step.message;
      state.progressTotal = event.data.total;
      state.progress.show(state.step.message, 0);
    } else {
      print(`${_chalk.default.yellow('●')} ${state.step.message}`);
    }
  }

  function onProgressTick(event) {
    const prog = state.progress;

    if (!prog) {
      return;
    }

    if (event.data.current >= prog.total) {
      return; // Will be taken care of by onProgressFinish
    }

    prog.show(state.step.message, event.data.current / state.progressTotal);
  }

  function onProgressFinish(event) {
    const prog = state.progress;

    if (!prog) {
      return;
    }

    prog.show(`${_chalk.default.green('✔')} ${state.step.message}`, 1);
  }

  function onStep(event) {
    state.step = event.data;
  }

  function onSuccess(event) {
    if (state.spinner) {
      state.spinner.stop();
    }

    if (state.progress) {
      state.progress.disable();
    }

    print(`\n${_chalk.default.green('✔')} Saved lockfile`);
  }

  function onFinished(event) {
    if (state.spinner) {
      state.spinner.stop();
    }

    const time = `${(event.data / 1000).toFixed(2)}s`;
    print(`${_chalk.default.green('✔')} Done in ${time}`);
  }

  function onWarning(event) {// For now, skip the warnings as they seem to only contain the first line of the text,
    // so it makes no sense to show it. Debug this later and consider reimplementing this.
  }

  function onError(event) {
    // Skip certain errors from being logged
    if (shouldIgnoreError(event)) {
      return;
    }

    if (state.spinner) {
      state.spinner.fail();
    }

    error(`${_chalk.default.red('✖')} ${event.data}`);
  }

  function onNativeError(err) {
    if (state.spinner) {
      state.spinner.fail();
    }

    throw err;
  }

  return proc.catch(err => {
    const detailed = new Error('Command failed :(');
    detailed.code = err.code;
    detailed.killed = err.killed;
    detailed.err = err.message;
    throw detailed;
  });
}

const ignoredMessages = ['install script for optional dependency', 'Command failed: yarn'];

function shouldIgnoreError(event) {
  if (!event || !event.data) {
    return false;
  }

  return ignoredMessages.some(ignore => event.data.indexOf(ignore) !== -1);
}