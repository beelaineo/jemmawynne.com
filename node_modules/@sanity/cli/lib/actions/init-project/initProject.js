"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = initSanity;

var _fs = _interopRequireDefault(require("fs"));

var _os = _interopRequireDefault(require("os"));

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _resolveFrom = _interopRequireDefault(require("resolve-from"));

var _deburr = _interopRequireDefault(require("lodash/deburr"));

var _noop = _interopRequireDefault(require("lodash/noop"));

var _safeJson = require("@sanity/util/lib/safeJson");

var _util = require("@sanity/util");

var _debug = _interopRequireDefault(require("../../debug"));

var _clientWrapper = _interopRequireDefault(require("../../util/clientWrapper"));

var _getUserConfig = _interopRequireDefault(require("../../util/getUserConfig"));

var _getProjectDefaults = _interopRequireDefault(require("../../util/getProjectDefaults"));

var _createProject = _interopRequireDefault(require("../project/createProject"));

var _login = _interopRequireDefault(require("../login/login"));

var _dynamicRequire = _interopRequireDefault(require("../../util/dynamicRequire"));

var _promptForDatasetName = _interopRequireDefault(require("./promptForDatasetName"));

var _bootstrapTemplate = _interopRequireDefault(require("./bootstrapTemplate"));

var _templates = _interopRequireDefault(require("./templates"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

/* eslint-disable no-process-env */
const isCI = process.env.CI;
const sanityEnv = process.env.SANITY_ENV;
const environment = sanityEnv ? sanityEnv : process.env.NODE_ENV;
/* eslint-enable no-process-env */
// eslint-disable-next-line max-statements, complexity

async function initSanity(args, context) {
  const {
    output,
    prompt,
    workDir,
    apiClient,
    yarn,
    chalk
  } = context;
  const cliFlags = args.extOptions;
  const unattended = cliFlags.y || cliFlags.yes;
  const print = unattended ? _noop.default : output.print;
  const specifiedOutputPath = cliFlags['output-path'];
  let reconfigure = cliFlags.reconfigure; // Check if we have a project manifest already

  const manifestPath = _path.default.join(workDir, 'sanity.json');

  let inProjectContext = false;
  let projectManifest;

  try {
    projectManifest = await _fsExtra.default.readJson(manifestPath);
    inProjectContext = Boolean(projectManifest.root);
  } catch (err) {// Intentional noop
  }

  const toDifferentPath = specifiedOutputPath && absolutify(specifiedOutputPath) !== workDir; // If explicitly reconfiguring, make sure we have something to reconfigure

  if (reconfigure && !inProjectContext) {
    throw new Error(projectManifest ? 'Reconfigure flag passed, but no `sanity.json` found' : 'Reconfigure flag passed, but `sanity.json` does not have "root" property set');
  } // If we are in a Sanity studio project folder and the project manifest has projectId/dataset,
  // ASK if we want to reconfigure. If no projectId/dataset is present, we assume reconfigure


  const hasProjectId = projectManifest && projectManifest.api && projectManifest.api.projectId;

  if (!toDifferentPath && hasProjectId && !reconfigure) {
    reconfigure = await promptImplicitReconfigure(prompt);

    if (!reconfigure) {
      print('Init cancelled. If you want to create a new project, try running `sanity init` in an empty folder');
      return;
    }
  } else if (!toDifferentPath) {
    reconfigure = inProjectContext;
  }

  if (reconfigure) {
    print(`The Sanity Studio in this folder will be tied to a new project on Sanity.io!`);

    if (hasProjectId) {
      print('The previous project configuration will be overwritten.');
    }

    print(`We're first going to make sure you have an account with Sanity.io. Hang on.`);
    print('Press ctrl + C at any time to quit.\n');
  } else {
    print(`You're setting up a new project!`);
    print(`We'll make sure you have an account with Sanity.io. Then we'll`);
    print('install an open-source JS content editor that connects to');
    print('the real-time hosted API on Sanity.io. Hang on.');
    print('Press ctrl + C at any time to quit.\n');
  } // If the user isn't already authenticated, make it so


  const userConfig = (0, _getUserConfig.default)();
  const hasToken = userConfig.get('authToken');
  (0, _debug.default)(hasToken ? 'User already has a token' : 'User has no token');

  if (hasToken) {
    print('Looks like you already have a Sanity-account. Sweet!\n');
  } else if (!unattended) {
    await getOrCreateUser();
  }

  const flags = await prepareFlags(cliFlags); // We're authenticated, now lets select or create a project

  (0, _debug.default)('Prompting user to select or create a project');
  const {
    projectId,
    displayName,
    isFirstProject
  } = await getOrCreateProject();
  const sluggedName = (0, _deburr.default)(displayName.toLowerCase()).replace(/\s+/g, '-').replace(/[^a-z0-9]/g, '');
  (0, _debug.default)(`Project with name ${displayName} selected`); // Now let's pick or create a dataset

  (0, _debug.default)('Prompting user to select or create a dataset');
  const {
    datasetName
  } = await getOrCreateDataset({
    projectId,
    displayName,
    dataset: flags.dataset,
    aclMode: flags.visibility
  });
  (0, _debug.default)(`Dataset with name ${datasetName} selected`);
  let outputPath = workDir;
  let successMessage;
  let defaults;

  if (reconfigure) {
    // Rewrite project manifest (sanity.json)
    const projectInfo = projectManifest.project || {};
    const newProps = {
      root: true,
      api: _objectSpread({}, projectManifest.api || {}, {
        projectId,
        dataset: datasetName
      }),
      project: _objectSpread({}, projectInfo, {
        // Keep original name if present
        name: projectInfo.name || displayName
      }) // Ensure root, api and project keys are at top to follow sanity.json key order convention

    };
    projectManifest = _objectSpread({}, newProps, projectManifest, newProps);
    await _fsExtra.default.outputJSON(manifestPath, projectManifest, {
      spaces: 2
    });
    const hasNodeModules = await _fsExtra.default.pathExists(_path.default.join(workDir, 'node_modules'));

    if (hasNodeModules) {
      print('Skipping installation of dependencies since node_modules exists.');
      print('Run sanity install to reinstall dependencies');
    } else {
      try {
        await yarn(['install'], _objectSpread({}, output, {
          rootDir: workDir
        }));
      } catch (err) {
        throw err;
      }
    }
  } else {
    // Gather project defaults based on environment
    defaults = await (0, _getProjectDefaults.default)(workDir, {
      isPlugin: false,
      context
    }); // Prompt the user for required information

    const answers = await getProjectInfo(); // Ensure we are using the output path provided by user

    outputPath = answers.outputPath || workDir; // Prompt for template to use

    const templateName = await selectProjectTemplate(); // Build a full set of resolved options

    const initOptions = _objectSpread({
      template: templateName,
      outputDir: outputPath,
      name: sluggedName,
      displayName: displayName,
      dataset: datasetName,
      projectId: projectId
    }, answers);

    const template = _templates.default[templateName];

    if (!template) {
      throw new Error(`Template "${templateName}" not found`);
    } // If the template has a sample dataset, prompt the user whether or not we should import it


    const shouldImport = !unattended && template.datasetUrl && (await promptForDatasetImport(template.importPrompt)); // Bootstrap Sanity, creating required project files, manifests etc

    await (0, _bootstrapTemplate.default)(initOptions, context); // Now for the slow part... installing dependencies

    try {
      await yarn(['install'], _objectSpread({}, output, {
        rootDir: outputPath
      }));
    } catch (err) {
      throw err;
    } // Make sure we have the required configs


    const coreCommands = (0, _dynamicRequire.default)(_resolveFrom.default.silent(outputPath, '@sanity/core')).commands;
    const configCheckCmd = coreCommands.find(cmd => cmd.name === 'configcheck');
    await configCheckCmd.action({
      extOptions: {
        quiet: true
      }
    }, Object.assign({}, context, {
      workDir: outputPath
    })); // Prompt for dataset import (if a dataset is defined)

    if (shouldImport) {
      await doDatasetImport();
    }

    if (shouldImport) {
      print('');
      print('If you want to delete the imported data, use');
      print(`\t${chalk.cyan(`sanity dataset delete ${datasetName}`)}`);
      print('and create a new clean dataset with');
      print(`\t${chalk.cyan(`sanity dataset create <name>`)}\n`);
    } // See if the template has a success message handler and print it


    successMessage = template.getSuccessMessage ? template.getSuccessMessage(initOptions, context) : '';
  }

  print(`\n${chalk.green('Success!')} Now what?\n`);
  const isCurrentDir = outputPath === process.cwd();

  if (!isCurrentDir) {
    print(`▪ ${chalk.cyan(`cd ${outputPath}`)}, then:`);
  }

  print(`▪ ${chalk.cyan('sanity docs')} to open the documentation in a browser`);
  print(`▪ ${chalk.cyan('sanity manage')} to open the project settings in a browser`);
  print(`▪ ${chalk.cyan('sanity help')} to explore the CLI manual`);
  print(`▪ ${chalk.green('sanity start')} to run your studio\n`);

  if (successMessage) {
    print(`\n${successMessage}`);
  }

  const sendInvite = isFirstProject && (await prompt.single({
    type: 'confirm',
    message: 'We have an excellent developer community, would you like us to send you an invitation to join?',
    default: true
  }));

  if (sendInvite) {
    apiClient({
      requireProject: false
    }).request({
      uri: '/invitations/community',
      method: 'POST'
    }).catch(_noop.default);
  }

  async function getOrCreateUser() {
    print(`We can't find any auth credentials in your Sanity config`);
    print('- log in or create a new account\n'); // Provide login options (`sanity login`)

    await (0, _login.default)(args, context);
    print("Good stuff, you're now authenticated. You'll need a project to keep your");
    print('datasets and collaborators safe and snug.');
  }

  async function getOrCreateProject() {
    let projects;

    try {
      projects = await apiClient({
        requireProject: false
      }).projects.list();
    } catch (err) {
      if (unattended) {
        return {
          projectId: flags.project,
          displayName: 'Unknown project',
          isFirstProject: false
        };
      }

      throw new Error(`Failed to communicate with the Sanity API:\n${err.message}`);
    }

    if (projects.length === 0 && unattended) {
      throw new Error('No projects found for current user');
    }

    if (flags.project) {
      const project = projects.find(proj => proj.id === flags.project);

      if (!project && !unattended) {
        throw new Error(`Given project ID (${flags.project}) not found, or you do not have access to it`);
      }

      return {
        projectId: flags.project,
        displayName: project ? project.displayName : 'Unknown project',
        isFirstProject: false
      };
    }

    const isFirstProject = projects.length === 0;

    if (isFirstProject) {
      (0, _debug.default)('No projects found for user, prompting for name');
      const projectName = await prompt.single({
        message: 'Project name'
      });
      return (0, _createProject.default)(apiClient, {
        displayName: projectName
      }).then(response => _objectSpread({}, response, {
        isFirstProject
      }));
    }

    (0, _debug.default)(`User has ${projects.length} project(s) already, showing list of choices`);
    const projectChoices = projects.map(project => ({
      value: project.id,
      name: `${project.displayName} [${project.id}]`
    }));
    const selected = await prompt.single({
      message: 'Select project to use',
      type: 'list',
      choices: [{
        value: 'new',
        name: 'Create new project'
      }, new prompt.Separator(), ...projectChoices]
    });

    if (selected === 'new') {
      (0, _debug.default)('User wants to create a new project, prompting for name');
      return (0, _createProject.default)(apiClient, {
        displayName: await prompt.single({
          message: 'Informal name for your project'
        })
      }).then(response => _objectSpread({}, response, {
        isFirstProject
      }));
    }

    (0, _debug.default)(`Returning selected project (${selected})`);
    return {
      projectId: selected,
      displayName: projects.find(proj => proj.id === selected).displayName,
      isFirstProject
    };
  }

  async function getOrCreateDataset(opts) {
    if (opts.dataset && isCI) {
      return {
        datasetName: opts.dataset
      };
    }

    const client = apiClient({
      api: {
        projectId: opts.projectId
      }
    });
    const [datasets, projectFeatures] = await Promise.all([client.datasets.list(), client.request({
      uri: '/features'
    })]);
    const privateDatasetsAllowed = projectFeatures.includes('privateDataset');
    const allowedModes = privateDatasetsAllowed ? ['public', 'private'] : ['public'];

    if (opts.aclMode && !allowedModes.includes(opts.aclMode)) {
      throw new Error(`Visibility mode "${opts.aclMode}" not allowed`);
    } // Getter in order to present prompts in a more logical order


    const getAclMode = () => {
      if (opts.aclMode) {
        return opts.aclMode;
      }

      if (unattended || !privateDatasetsAllowed) {
        return 'public';
      } else if (privateDatasetsAllowed) {
        return promptForAclMode(prompt, output);
      }

      return opts.aclMode;
    };

    if (opts.dataset) {
      (0, _debug.default)('User has specified dataset through a flag (%s)', opts.dataset);
      const existing = datasets.find(ds => ds.name === opts.dataset);

      if (!existing) {
        (0, _debug.default)('Specified dataset not found, creating it');
        const aclMode = await getAclMode();
        await client.datasets.create(opts.dataset, {
          aclMode
        });
      }

      return {
        datasetName: opts.dataset
      };
    }

    if (datasets.length === 0) {
      (0, _debug.default)('No datasets found for project, prompting for name');
      const name = await (0, _promptForDatasetName.default)(prompt, {
        message: 'Name of your first dataset:',
        default: 'production'
      });
      const aclMode = await getAclMode();
      await client.datasets.create(name, {
        aclMode
      });
      return {
        datasetName: name
      };
    }

    (0, _debug.default)(`User has ${datasets.length} dataset(s) already, showing list of choices`);
    const datasetChoices = datasets.map(dataset => ({
      value: dataset.name
    }));
    const selected = await prompt.single({
      message: 'Select dataset to use',
      type: 'list',
      choices: [{
        value: 'new',
        name: 'Create new dataset'
      }, new prompt.Separator(), ...datasetChoices]
    });

    if (selected === 'new') {
      (0, _debug.default)('User wants to create a new dataset, prompting for name');
      const newDatasetName = await (0, _promptForDatasetName.default)(prompt, {
        message: 'Name your dataset:',
        default: 'production'
      });
      const aclMode = await getAclMode();
      await client.datasets.create(newDatasetName, {
        aclMode
      });
      return {
        datasetName: newDatasetName
      };
    }

    (0, _debug.default)(`Returning selected dataset (${selected})`);
    return {
      datasetName: selected
    };
  }

  function promptForDatasetImport(message) {
    return prompt.single({
      type: 'confirm',
      message: message || 'This template includes a sample dataset, would you like to use it?',
      default: true
    });
  }

  function selectProjectTemplate() {
    const defaultTemplate = unattended || flags.template ? flags.template || 'clean' : null;

    if (defaultTemplate) {
      return defaultTemplate;
    }

    return prompt.single({
      message: 'Select project template',
      type: 'list',
      choices: [{
        value: 'moviedb',
        name: 'Movie project (schema + sample data)'
      }, {
        value: 'ecommerce',
        name: 'E-commerce (schema + sample data)'
      }, {
        value: 'blog',
        name: 'Blog (schema)'
      }, {
        value: 'clean',
        name: 'Clean project with no predefined schemas'
      }]
    });
  }

  async function doDatasetImport() {
    const manifestPath = _path.default.join(outputPath, 'sanity.json');

    const baseManifest = await (0, _safeJson.loadJson)(manifestPath);
    const manifest = (0, _util.reduceConfig)(baseManifest || {}, environment);
    const importCmd = coreCommands.find(cmd => cmd.name === 'import' && cmd.group === 'dataset');
    return importCmd.action({
      argsWithoutOptions: [template.datasetUrl, datasetName],
      extOptions: {}
    }, Object.assign({}, context, {
      apiClient: (0, _clientWrapper.default)(manifest, manifestPath),
      workDir: outputPath,
      fromInitCommand: true
    }));
  }

  async function getProjectInfo() {
    const specifiedPath = flags['output-path'] && _path.default.resolve(flags['output-path']);

    if (unattended) {
      return Object.assign({
        license: 'UNLICENSED'
      }, defaults, {
        outputPath: specifiedPath
      });
    }

    const workDirIsEmpty = (await _fsExtra.default.readdir(workDir)).length === 0;
    return {
      description: defaults.description,
      gitRemote: defaults.gitRemote,
      author: defaults.author,
      license: 'UNLICENSED',
      outputPath: specifiedPath || (await prompt.single({
        type: 'input',
        message: 'Output path:',
        default: workDirIsEmpty ? workDir : _path.default.join(workDir, sluggedName),
        validate: validateEmptyPath,
        filter: absolutify
      }))
    };
  }

  async function prepareFlags() {
    const createProjectName = cliFlags['create-project'];

    if (cliFlags.project && createProjectName) {
      throw new Error('Both `--project` and `--create-project` specified, only a single is supported');
    }

    if (createProjectName === true) {
      throw new Error('Please specify a project name (`--create-project <name>`)');
    }

    if (typeof createProjectName === 'string' && createProjectName.trim().length === 0) {
      throw new Error('Please specify a project name (`--create-project <name>`)');
    }

    if (unattended) {
      (0, _debug.default)('Unattended mode, validating required options');
      const requiredForUnattended = ['dataset', 'output-path'];
      requiredForUnattended.forEach(flag => {
        if (!cliFlags[flag]) {
          throw new Error(`\`--${flag}\` must be specified in unattended mode`);
        }
      });

      if (!cliFlags.project && !createProjectName) {
        throw new Error('`--project <id>` or `--create-project <name>` must be specified in unattended mode');
      }
    }

    if (createProjectName) {
      (0, _debug.default)('--create-project specified, creating a new project');
      const createdProject = await (0, _createProject.default)(apiClient, {
        displayName: createProjectName.trim()
      });
      (0, _debug.default)('Project with ID %s created', createdProject.projectId);

      if (cliFlags.dataset) {
        (0, _debug.default)('--dataset specified, creating dataset (%s)', cliFlags.dataset);
        const client = apiClient({
          api: {
            projectId: createdProject.projectId
          }
        });
        await client.datasets.create(cliFlags.dataset);
      }

      const newFlags = Object.assign({}, cliFlags, {
        project: createdProject.projectId
      });
      delete newFlags['create-project'];
      return newFlags;
    }

    return cliFlags;
  }
}

function promptImplicitReconfigure(prompt) {
  return prompt.single({
    type: 'confirm',
    message: 'The current folder contains a configured Sanity studio. Would you like to reconfigure it?',
    default: true
  });
}

function validateEmptyPath(dir) {
  const checkPath = absolutify(dir);
  return pathIsEmpty(checkPath) ? true : 'Given path is not empty';
}

function pathIsEmpty(dir) {
  // We are using fs instead of fs-extra because it silently, weirdly, crashes on windows
  try {
    // eslint-disable-next-line no-sync
    const content = _fs.default.readdirSync(dir);

    return content.length === 0;
  } catch (err) {
    if (err.code === 'ENOENT') {
      return true;
    }

    throw err;
  }
}

function expandHome(filePath) {
  if (filePath.charCodeAt(0) === 126
  /* ~ */
  ) {
      if (filePath.charCodeAt(1) === 43
      /* + */
      ) {
          return _path.default.join(process.cwd(), filePath.slice(2));
        }

      const home = _os.default.homedir();

      return home ? _path.default.join(home, filePath.slice(1)) : filePath;
    }

  return filePath;
}

function absolutify(dir) {
  const pathName = expandHome(dir);
  return _path.default.isAbsolute(pathName) ? pathName : _path.default.resolve(process.cwd(), pathName);
}

async function promptForAclMode(prompt, output) {
  const mode = await prompt.single({
    type: 'list',
    message: 'Choose dataset visibility – this can be changed later',
    choices: [{
      value: 'public',
      name: 'Public (world readable)'
    }, {
      value: 'private',
      name: 'Private (Authenticated user or token needed for API requests)'
    }]
  });

  if (mode === 'private') {
    output.print('Please note that while documents are private, assets (files and images) are still public\n');
  }

  return mode;
}