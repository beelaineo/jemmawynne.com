"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = login;

var _os = _interopRequireDefault(require("os"));

var _url = _interopRequireDefault(require("url"));

var _opn = _interopRequireDefault(require("opn"));

var _chalk = _interopRequireDefault(require("chalk"));

var _crypto = _interopRequireDefault(require("crypto"));

var _eventsource = _interopRequireDefault(require("eventsource"));

var _safeJson = require("@sanity/util/lib/safeJson");

var _getUserConfig = _interopRequireDefault(require("../../util/getUserConfig"));

var _canLaunchBrowser = _interopRequireDefault(require("../../util/canLaunchBrowser"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

async function login(args, context) {
  const {
    prompt,
    output,
    apiClient
  } = context;
  const client = apiClient({
    requireUser: false,
    requireProject: false
  }); // Fetch and prompt for login provider to use

  let spin = output.spinner('Fetching providers...').start();
  const {
    providers
  } = await client.request({
    uri: '/auth/providers'
  });
  spin.stop();
  const provider = await promptProviders(prompt, providers); // Open an authentication listener channel and wait for secret

  const iv = _crypto.default.randomBytes(8).toString('hex');

  const es = getAuthChannel(client.config().apiHost, provider, iv);
  const encryptedToken = getAuthToken(es); // This is a promise, will resolve later

  const {
    secret,
    url
  } = await getAuthInfo(es); // Open a browser on the login page (or tell the user to)

  const providerUrl = _url.default.parse(url, true);

  providerUrl.query.label = `${_os.default.hostname()} / ${_os.default.platform()}`;

  const loginUrl = _url.default.format(providerUrl);

  const shouldLaunchBrowser = (0, _canLaunchBrowser.default)();
  const actionText = shouldLaunchBrowser ? 'Opening browser at' : 'Please open a browser at';
  output.print(`\n${actionText} ${loginUrl}\n`);
  spin = output.spinner('Waiting for browser login to complete... Press Ctrl + C to cancel').start();
  (0, _opn.default)(loginUrl, {
    wait: false
  }); // Wait for a success/error on the listener channel

  let token;

  try {
    token = await encryptedToken;
    spin.stop();
  } catch (err) {
    spin.stop();
    err.message = `Login failed: ${err.message}`;
    throw err;
  } // Decrypt the token with the secret we received earlier


  const authToken = decryptToken(token, secret, iv); // Store the token

  (0, _getUserConfig.default)().set({
    authToken: authToken,
    authType: 'normal'
  });
  output.print(_chalk.default.green('Login successful'));
}

function getAuthChannel(baseUrl, provider, iv) {
  const uuid = _crypto.default.randomBytes(16).toString('hex');

  const listenUrl = `${baseUrl}/v1/auth/listen/${provider.name}/${uuid}?iv=${iv}`;
  return new _eventsource.default(listenUrl);
}

function getAuthInfo(es) {
  const wantedProps = ['secret', 'url'];
  const values = {};
  return new Promise(resolve => {
    let numProps = 0;
    es.addEventListener('message', msg => {
      const data = (0, _safeJson.parseJson)(msg.data, {});

      if (!wantedProps.includes(data.type)) {
        return;
      }

      values[data.type] = data[data.type];

      if (++numProps === wantedProps.length) {
        resolve(values);
      }
    });
  });
}

function getAuthToken(es) {
  return new Promise((resolve, reject) => {
    es.addEventListener('success', msg => {
      es.close();
      const data = (0, _safeJson.parseJson)(msg.data, {});
      resolve(data.token);
    });
    es.addEventListener('failure', msg => {
      es.close();
      const data = (0, _safeJson.parseJson)(msg.data, {});
      const error = new Error(data.message);
      Object.keys(data).forEach(key => {
        error[key] = data[key];
      });
      reject(error);
    });
  });
}

function decryptToken(token, secret, iv) {
  const decipher = _crypto.default.createDecipheriv('aes-256-cbc', secret, iv);

  const dec = decipher.update(token, 'hex', 'utf8');
  return `${dec}${decipher.final('utf8')}`;
}

function promptProviders(prompt, providers) {
  if (providers.length === 1) {
    return providers[0];
  }

  return prompt.single({
    type: 'list',
    message: 'Login type',
    choices: providers.map(provider => provider.title)
  }).then(provider => providers.find(prov => prov.title === provider));
}