"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _boxen = _interopRequireDefault(require("boxen"));

var _chalk = _interopRequireDefault(require("chalk"));

var _getLatestVersion = _interopRequireDefault(require("get-latest-version"));

var _semverCompare = _interopRequireDefault(require("semver-compare"));

var _pTimeout = _interopRequireDefault(require("p-timeout"));

var _debug = _interopRequireDefault(require("../debug"));

var _getUserConfig = _interopRequireDefault(require("./getUserConfig"));

var _getUpgradeCommand = _interopRequireDefault(require("./getUpgradeCommand"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-process-env */
const MAX_BLOCKING_TIME = 300;
const TWELVE_HOURS = 1000 * 60 * 60 * 12;
const isDisabled = process.env.CI || // Travis CI, CircleCI, Gitlab CI, Appveyor, CodeShip
process.env.CONTINUOUS_INTEGRATION || // Travis CI
process.env.BUILD_NUMBER || // Jenkins, TeamCity
process.env.NO_UPDATE_NOTIFIER; // Explicitly disabled

var _default = options => {
  (0, _debug.default)('CLI installed at %s', __dirname);
  const {
    pkg,
    cwd,
    workDir
  } = options;
  const {
    name,
    version
  } = pkg;
  const userConfig = (0, _getUserConfig.default)();
  const check = getLatestRemote().catch(() => false);
  let hasPrintedResult = false;
  return {
    notify
  };

  async function notify() {
    if (!process.stdout.isTTY) {
      return;
    }

    const result = await (0, _pTimeout.default)(check, MAX_BLOCKING_TIME, printCachedResult);

    if (hasPrintedResult) {
      (0, _debug.default)('Has already printed result through timeout check, skipping result notification');
      return;
    }

    printResult(result);
  }

  function printCachedResult() {
    (0, _debug.default)('Max time (%dms) reached waiting for latest version info', MAX_BLOCKING_TIME);
    hasPrintedResult = true;
    const cached = userConfig.get('cliHasUpdate');

    if (!cached) {
      (0, _debug.default)('No cached latest version result found');
      return;
    }

    const diff = (0, _semverCompare.default)(cached, version);

    if (diff <= 0) {
      // Looks like CLI was upgraded since last check
      (0, _debug.default)('CLI was upgraded since last check, falling back');
      userConfig.delete('cliHasUpdate');
      return;
    }

    (0, _debug.default)('Printing cached latest version result');
    printResult(cached);
  }

  function printResult(newVersion) {
    hasPrintedResult = true;
    const lastUpdated = userConfig.get('cliLastUpdateNag') || 0;

    if (Date.now() - lastUpdated < TWELVE_HOURS) {
      (0, _debug.default)('Less than 12 hours since last nag, skipping');
      return;
    }

    if (!newVersion || (0, _semverCompare.default)(newVersion, version) <= 0) {
      (0, _debug.default)(`New version is ${newVersion || 'unknown'}, current is ${version}. Falling back.`);
      return;
    }

    const upgradeCommand = (0, _getUpgradeCommand.default)({
      cwd,
      workDir
    });
    const message = ['Update available ', _chalk.default.dim(version), _chalk.default.reset(' â†’ '), _chalk.default.green(newVersion), ' \nRun ', _chalk.default.cyan(upgradeCommand), ' to update'].join('');
    const boxenOpts = {
      padding: 1,
      margin: 1,
      align: 'center',
      borderColor: 'yellow',
      borderStyle: 'round' // Print to stderr to prevent garbling command output
      // eslint-disable-next-line no-console

    };
    console.error(`\n${(0, _boxen.default)(message, boxenOpts)}`);
    userConfig.set('cliLastUpdateNag', Date.now());
  }

  async function getLatestRemote() {
    if (isDisabled) {
      (0, _debug.default)('Running on CI, or explicitly disabled, skipping update check');
      return false;
    }

    const lastUpdated = userConfig.get('cliLastUpdateCheck') || 0;

    if (Date.now() - lastUpdated < TWELVE_HOURS) {
      (0, _debug.default)('Less than 12 hours since last check, skipping update check');
      return userConfig.get('cliHasUpdate') || false;
    }

    let latestRemote;

    try {
      (0, _debug.default)('Checking for latest remote version');
      latestRemote = await (0, _getLatestVersion.default)(name);
      (0, _debug.default)('Latest remote version is %s', latestRemote);
    } catch (err) {
      (0, _debug.default)(`Failed to fetch latest version of ${name} from npm:\n${err.stack}`);
      return false;
    }

    userConfig.set('cliLastUpdateCheck', Date.now());
    const diff = (0, _semverCompare.default)(latestRemote, version);

    if (diff <= 0) {
      // No change, or lower
      (0, _debug.default)(diff === 0 ? 'No update found' : 'Remote version older than local');
      userConfig.delete('cliHasUpdate');
      return false;
    } // Update available, set to user config so we may notify on next startup


    userConfig.set('cliHasUpdate', latestRemote);
    (0, _debug.default)('Update is available (%s)', latestRemote);
    return latestRemote;
  }
};

exports.default = _default;