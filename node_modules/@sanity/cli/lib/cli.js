"use strict";

require("babel-polyfill");

var _path = _interopRequireDefault(require("path"));

var _chalk = _interopRequireDefault(require("chalk"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _neatStack = _interopRequireDefault(require("neat-stack"));

var _resolveFrom = _interopRequireDefault(require("resolve-from"));

var _resolver = require("@sanity/resolver");

var _package = _interopRequireDefault(require("../package.json"));

var _updateNotifier = _interopRequireDefault(require("./util/updateNotifier"));

var _parseArguments = _interopRequireDefault(require("./util/parseArguments"));

var _mergeCommands = _interopRequireDefault(require("./util/mergeCommands"));

var _CommandRunner = require("./CommandRunner");

var _commands = _interopRequireDefault(require("./commands"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint-disable no-console, no-process-exit, no-sync */
// eslint-disable-next-line import/no-unassigned-import
const sanityEnv = process.env.SANITY_ENV || 'production'; // eslint-disable-line no-process-env

const knownEnvs = ['development', 'staging', 'production'];

module.exports = async function runCli(cliRoot) {
  installUnhandledRejectionsHandler();
  const args = (0, _parseArguments.default)();
  const isInit = args.groupOrCommand === 'init' && args.argsWithoutOptions[0] !== 'plugin';
  const cwd = checkCwdPresence();
  const workDir = isInit ? process.cwd() : resolveRootDir(cwd);
  await (0, _updateNotifier.default)({
    pkg: _package.default,
    cwd,
    workDir
  }).notify();
  const options = {
    cliRoot: cliRoot,
    workDir: workDir,
    corePath: getCoreModulePath(workDir)
  };
  warnOnNonProductionEnvironment();
  warnOnInferredProjectDir(isInit, cwd, workDir);
  const core = args.coreOptions;
  const commands = (0, _mergeCommands.default)(_commands.default, options.corePath);

  if (core.v || core.version) {
    console.log(`${_package.default.name} version ${_package.default.version}`);
    process.exit();
  } // Translate `sanity -h <command>` to `sanity help <command>`


  if (core.h || core.help) {
    if (args.groupOrCommand) {
      args.argsWithoutOptions.unshift(args.groupOrCommand);
    }

    args.groupOrCommand = 'help';
  }

  const cliRunner = (0, _CommandRunner.getCliRunner)(commands);
  cliRunner.runCommand(args.groupOrCommand, args, options).catch(err => {
    const error = err.details || err; // eslint-disable-next-line no-console

    console.error(error.stack ? (0, _neatStack.default)(err) : error); // eslint-disable-next-line no-process-exit

    process.exit(1);
  });
};

function getCoreModulePath(workDir) {
  const pkgPath = _resolveFrom.default.silent(workDir, '@sanity/core');

  if (pkgPath) {
    return pkgPath;
  }

  const hasManifest = _fsExtra.default.existsSync(_path.default.join(workDir, 'sanity.json'));

  if (hasManifest && process.argv.indexOf('install') === -1) {
    console.warn(_chalk.default.yellow(['@sanity/core not installed in current project', 'Project-specific commands not available until you run `sanity install`'].join('\n')));
  }

  return undefined;
} // Weird edge case where the folder the terminal is currently in has been removed


function checkCwdPresence() {
  let pwd;

  try {
    pwd = process.cwd();
  } catch (err) {
    if (err.code === 'ENOENT') {
      console.error('[ERR] Could not resolve working directory, does the current folder exist?');
      process.exit(1);
    } else {
      throw err;
    }
  }

  return pwd;
}

function resolveRootDir(cwd) {
  // Resolve project root directory
  try {
    return (0, _resolver.resolveProjectRoot)({
      basePath: cwd,
      sync: true
    }) || cwd;
  } catch (err) {
    console.warn(_chalk.default.red(['Error occured trying to resolve project root:', err.message].join('\n')));
    process.exit(1);
  }

  return false;
}

function installUnhandledRejectionsHandler() {
  process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled rejection:', reason.stack);
  });
}

function warnOnInferredProjectDir(isInit, cwd, workDir) {
  if (isInit || cwd === workDir) {
    return;
  }

  console.log(`Not in project directory, assuming context of project at ${workDir}`);
}

function warnOnNonProductionEnvironment() {
  if (sanityEnv === 'production') {
    return;
  }

  console.warn(_chalk.default.yellow(knownEnvs.includes(sanityEnv) ? `[WARN] Running in ${sanityEnv} environment mode\n` : `[WARN] Running in ${_chalk.default.red('UNKNOWN')} "${sanityEnv}" environment mode\n`));
}