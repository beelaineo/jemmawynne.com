"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _omit2 = _interopRequireDefault(require("lodash/omit"));

var _pick2 = _interopRequireDefault(require("lodash/pick"));

var _os = _interopRequireDefault(require("os"));

var _util = _interopRequireDefault(require("util"));

var _path = _interopRequireDefault(require("path"));

var _osenv = _interopRequireDefault(require("osenv"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _xdgBasedir = _interopRequireDefault(require("xdg-basedir"));

var _promisePropsRecursive = _interopRequireDefault(require("promise-props-recursive"));

var _getUserConfig = _interopRequireDefault(require("../../util/getUserConfig"));

var _printVersionResult = require("../versions/printVersionResult");

var _findSanityModuleVersions = _interopRequireDefault(require("../../actions/versions/findSanityModuleVersions"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _default = async (args, context) => {
  const flags = args.extOptions;
  const {
    user,
    globalConfig,
    projectConfig,
    project,
    versions
  } = await gatherInfo(context);
  const {
    chalk
  } = context; // User info

  context.output.print('\nUser:');

  if (user instanceof Error) {
    context.output.print(`  ${chalk.red(user.message)}\n`);
  } else {
    printKeyValue({
      ID: user.id,
      Name: user.name,
      Email: user.email
    }, context);
  } // Project info (API-based)


  if (project) {
    context.output.print('Project:');
    printKeyValue({
      ID: project.id,
      'Display name': project.displayName,
      'Studio URL': project.studioHostname || project.studioHost,
      'User role': project.userRole
    }, context);
  } // Auth info
  // eslint-disable-next-line no-process-env


  const authToken = process.env.SANITY_AUTH_TOKEN || globalConfig.authToken;

  if (authToken) {
    context.output.print('Authentication:');
    printKeyValue({
      'User type': globalConfig.authType || 'normal',
      'Auth token': flags.secrets ? authToken : `<redacted>`
    }, context);

    if (!flags.secrets) {
      context.output.print('  (run with --secrets to reveal token)\n');
    }
  } // Global configuration (user home dir config file)


  context.output.print(`Global config (${chalk.yellow(getGlobalConfigLocation())}):`);
  const globalCfg = (0, _omit2.default)(globalConfig, ['authType', 'authToken']);
  context.output.print(`  ${formatObject(globalCfg).replace(/\n/g, '\n  ')}\n`); // Project configuration (projectDir/sanity.json)

  if (projectConfig) {
    const configLocation = _path.default.join(context.workDir, 'sanity.json');

    context.output.print(`Project config (${chalk.yellow(configLocation)}):`);
    context.output.print(`  ${formatObject(projectConfig).replace(/\n/g, '\n  ')}`);
  } // Print installed package versions


  if (versions) {
    context.output.print('\nPackage versions:');
    (0, _printVersionResult.printResult)(versions, line => context.output.print(`  ${line}`));
    context.output.print('');
  }
};

exports.default = _default;

function formatObject(obj) {
  return _util.default.inspect(obj, {
    colors: true,
    depth: +Infinity
  });
}

function printKeyValue(obj, context) {
  let printedLines = 0;
  Object.keys(obj).forEach(key => {
    if (typeof obj[key] !== 'undefined') {
      context.output.print(`  ${key}: ${formatObject(obj[key])}`);
      printedLines++;
    }
  });

  if (printedLines > 0) {
    context.output.print('');
  }
}

async function gatherInfo(context) {
  const baseInfo = await (0, _promisePropsRecursive.default)({
    globalConfig: gatherGlobalConfigInfo(context),
    projectConfig: gatherProjectConfigInfo(context)
  });
  baseInfo.user = await gatherUserInfo(context, {
    projectBased: Boolean(baseInfo.projectConfig && baseInfo.projectConfig.api)
  });
  return (0, _promisePropsRecursive.default)(Object.assign({
    project: gatherProjectInfo(context, baseInfo),
    versions: (0, _findSanityModuleVersions.default)(context)
  }, baseInfo));
}

function getGlobalConfigLocation() {
  const user = (_osenv.default.user() || 'user').replace(/\\/g, '');

  const configDir = _xdgBasedir.default.config || _path.default.join(_os.default.tmpdir(), user, '.config');

  return _path.default.join(configDir, 'sanity', 'config.json');
}

function gatherGlobalConfigInfo(context) {
  return (0, _getUserConfig.default)().all;
}

async function gatherProjectConfigInfo(context) {
  const workDir = context.workDir;

  const configLocation = _path.default.join(workDir, 'sanity.json');

  try {
    const config = await _fsExtra.default.readJson(configLocation);

    if (!config.api || !config.api.projectId) {
      throw new Error(`Project config (${configLocation}) does not contain required "api.projectId" key`);
    }

    return config;
  } catch (err) {
    return err.code === 'ENOENT' ? null : {
      error: err
    };
  }
}

async function gatherProjectInfo(context, baseInfo) {
  const client = context.apiClient({
    requireUser: false,
    requireProject: false
  });
  const projectId = client.config().projectId;

  if (!projectId) {
    return null;
  }

  const projectInfo = await client.projects.getById(projectId);

  if (!projectInfo) {
    return new Error(`Project specified in configuration (${projectId}) does not exist in API`);
  }

  const host = projectInfo.studioHostname || projectInfo.studioHost;
  const member = (projectInfo.members || []).find(user => user.id === baseInfo.user.id);
  const hostname = host && `https://${host}.sanity.studio/`;
  return {
    id: projectId,
    displayName: projectInfo.displayName,
    studioHostname: hostname,
    userRole: member ? member.role : 'unknown'
  };
}

async function gatherUserInfo(context, info = {}) {
  const client = context.apiClient({
    requireUser: false,
    requireProject: info.projectBased
  });
  const hasToken = Boolean(client.config().token);

  if (!hasToken) {
    return new Error('Not logged in');
  }

  const userInfo = await client.users.getById('me');

  if (!userInfo) {
    return new Error('Token expired or invalid');
  }

  return (0, _pick2.default)(userInfo, ['id', 'name', 'email']);
}