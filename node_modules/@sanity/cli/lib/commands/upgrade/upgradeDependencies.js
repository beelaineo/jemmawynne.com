"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _noop2 = _interopRequireDefault(require("lodash/noop"));

var _padStart2 = _interopRequireDefault(require("lodash/padStart"));

var _path = _interopRequireDefault(require("path"));

var _fsExtra = _interopRequireDefault(require("fs-extra"));

var _semver = _interopRequireDefault(require("semver"));

var _readLocalManifest = _interopRequireDefault(require("@sanity/util/lib/readLocalManifest"));

var _findSanityModuleVersions = _interopRequireDefault(require("../../actions/versions/findSanityModuleVersions"));

var _printVersionResult = require("../versions/printVersionResult");

var _debug = _interopRequireDefault(require("../../debug"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

async function deleteIfNotSymlink(modPath) {
  const stats = await _fsExtra.default.lstat(modPath).catch(_noop2.default);

  if (!stats || stats.isSymbolicLink()) {
    return null;
  }

  return _fsExtra.default.remove(modPath);
}

var _default = async (args, context) => {
  const {
    output,
    workDir,
    yarn,
    chalk
  } = context;
  const {
    extOptions,
    argsWithoutOptions
  } = args;
  const modules = argsWithoutOptions.slice();
  const {
    range,
    tag
  } = extOptions;
  const saveExact = extOptions['save-exact'];
  const targetRange = tag || range || 'latest';

  if (range && tag) {
    throw new Error('Both --tag and --range specified, can only use one');
  }

  if (range && !_semver.default.validRange(range)) {
    throw new Error(`Invalid semver range "${range}"`);
  } // Find which modules needs update according to the target range


  const allNeedsUpdate = await getModulesInNeedOfUpdate(context, targetRange);
  (0, _debug.default)('In need of update: %s', allNeedsUpdate.map(mod => mod.name).join(', '));
  const needsUpdate = modules.length === 0 ? allNeedsUpdate : allNeedsUpdate.filter(outOfDate => modules.indexOf(outOfDate.name) !== -1); // If all modules are up-to-date, say so and exit

  if (needsUpdate.length === 0) {
    const specified = modules.length === 0 ? 'All' : 'All *specified*';
    context.output.print(`${chalk.green('✔')} ${specified} Sanity modules are at latest versions`);
    return;
  } // Forcefully remove non-symlinked module paths to force upgrade


  await Promise.all(needsUpdate.map(mod => deleteIfNotSymlink(_path.default.join(context.workDir, 'node_modules', mod.name.replace(/\//g, _path.default.sep))))); // Replace versions in `package.json`

  const versionPrefix = saveExact ? '' : '^';
  const oldManifest = await (0, _readLocalManifest.default)(workDir);
  const newManifest = needsUpdate.reduce((target, mod) => {
    if (oldManifest.dependencies && oldManifest.dependencies[mod.name]) {
      target.dependencies[mod.name] = mod.latest === 'unknown' ? oldManifest.dependencies[mod.name] : versionPrefix + mod.latest;
    }

    if (oldManifest.devDependencies && oldManifest.devDependencies[mod.name]) {
      target.devDependencies[mod.name] = mod.latest === 'unknown' ? oldManifest.devDependencies[mod.name] : versionPrefix + mod.latest;
    }

    return target;
  }, oldManifest); // Write new `package.json`

  const manifestPath = _path.default.join(context.workDir, 'package.json');

  await _fsExtra.default.writeJson(manifestPath, newManifest, {
    spaces: 2
  }); // Delete `yarn.lock` to ensure we're getting new modules
  // (workaround, shouldnt be needed in the future)

  const yarnLockPath = _path.default.join(context.workDir, 'yarn.lock');

  const hasLockFile = _fsExtra.default.existsSync(yarnLockPath); // eslint-disable-line no-sync


  if (hasLockFile) {
    await _fsExtra.default.unlink(yarnLockPath);
  } // Run `yarn install`


  const flags = extOptions.offline ? ['--offline'] : [];
  const cmd = ['install'].concat(flags);
  (0, _debug.default)('Running yarn %s', cmd.join(' '));
  await yarn(cmd, _objectSpread({}, output, {
    rootDir: workDir
  }));
  context.output.print('');
  context.output.print(`${chalk.green('✔')} Modules upgraded:`);
  const {
    versionLength,
    formatName
  } = (0, _printVersionResult.getFormatters)(needsUpdate);
  needsUpdate.forEach(mod => {
    const current = chalk.yellow((0, _padStart2.default)(mod.version, versionLength));
    const latest = chalk.green(mod.latest);
    context.output.print(`${formatName(mod.name)} ${current} → ${latest}`);
  });
};

exports.default = _default;

async function getModulesInNeedOfUpdate(context, target) {
  const versions = await (0, _findSanityModuleVersions.default)(context, target, {
    includeCli: false
  });
  return versions.filter(mod => mod.needsUpdate);
}