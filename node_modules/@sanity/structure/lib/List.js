"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const SerializeError_1 = require("./SerializeError");
const ListItem_1 = require("./ListItem");
const GenericList_1 = require("./GenericList");
const getArgType = (thing) => {
    if (thing instanceof ListBuilder) {
        return 'ListBuilder';
    }
    if (isPromise(thing)) {
        return 'Promise';
    }
    return Array.isArray(thing) ? 'array' : typeof thing;
};
const isListItem = (item) => {
    return item.type === 'listItem';
};
const resolveChildForItem = (itemId, options) => {
    const parentItem = options.parent;
    const items = parentItem.items.filter(isListItem);
    const target = (items.find(item => item.id === itemId) || { child: undefined }).child;
    if (!target || typeof target !== 'function') {
        return target;
    }
    return typeof target === 'function' ? target(itemId, options) : target;
};
function maybeSerializeListItem(item, index, path) {
    if (item instanceof ListItem_1.ListItemBuilder) {
        return item.serialize({ path, index });
    }
    const listItem = item;
    if (listItem && listItem.type === 'divider') {
        return item;
    }
    if (!listItem || listItem.type !== 'listItem') {
        const gotWhat = (listItem && listItem.type) || getArgType(listItem);
        const helpText = gotWhat === 'array' ? ' - did you forget to spread (...moreItems)?' : '';
        throw new SerializeError_1.SerializeError(`List items must be of type "listItem", got "${gotWhat}"${helpText}`, path, index).withHelpUrl(SerializeError_1.HELP_URL.INVALID_LIST_ITEM);
    }
    return item;
}
function isPromise(thing) {
    return thing && typeof thing.then === 'function';
}
class ListBuilder extends GenericList_1.GenericListBuilder {
    constructor(spec) {
        super();
        this.spec = spec ? spec : {};
    }
    items(items) {
        return this.clone({ items });
    }
    getItems() {
        return this.spec.items;
    }
    serialize(options = { path: [] }) {
        const id = this.spec.id;
        if (typeof id !== 'string' || !id) {
            throw new SerializeError_1.SerializeError('`id` is required for lists', options.path, options.index).withHelpUrl(SerializeError_1.HELP_URL.ID_REQUIRED);
        }
        const items = typeof this.spec.items === 'undefined' ? [] : this.spec.items;
        if (!Array.isArray(items)) {
            throw new SerializeError_1.SerializeError('`items` must be an array of items', options.path, options.index).withHelpUrl(SerializeError_1.HELP_URL.LIST_ITEMS_MUST_BE_ARRAY);
        }
        const path = (options.path || []).concat(id);
        const serializedItems = items.map((item, index) => maybeSerializeListItem(item, index, path));
        const dupes = serializedItems.filter((val, i) => lodash_1.find(serializedItems, { id: val.id }, i + 1));
        if (dupes.length > 0) {
            const dupeIds = dupes.map(item => item.id).slice(0, 5);
            const dupeDesc = dupes.length > 5 ? `${dupeIds.join(', ')}...` : dupeIds.join(', ');
            throw new SerializeError_1.SerializeError(`List items with same ID found (${dupeDesc})`, options.path, options.index).withHelpUrl(SerializeError_1.HELP_URL.LIST_ITEM_IDS_MUST_BE_UNIQUE);
        }
        return Object.assign({}, super.serialize(options), { type: 'list', child: this.spec.child || resolveChildForItem, items: serializedItems });
    }
    clone(withSpec) {
        const builder = new ListBuilder();
        builder.spec = Object.assign({}, this.spec, (withSpec || {}));
        return builder;
    }
}
exports.ListBuilder = ListBuilder;

//# sourceMappingURL=List.js.map
