"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const getExtendedProjection_1 = require("./util/getExtendedProjection");
const Schema_1 = require("./parts/Schema");
const Icon_1 = require("./parts/Icon");
const Sort_1 = require("./Sort");
const SerializeError_1 = require("./SerializeError");
const SortIcon = Icon_1.getSortIcon();
function maybeSerializeMenuItem(item, index, path) {
    return item instanceof MenuItemBuilder ? item.serialize({ path, index }) : item;
}
exports.maybeSerializeMenuItem = maybeSerializeMenuItem;
class MenuItemBuilder {
    constructor(spec) {
        this.spec = spec ? spec : {};
    }
    action(action) {
        return this.clone({ action });
    }
    getAction() {
        return this.spec.action;
    }
    intent(intent) {
        return this.clone({ intent });
    }
    getIntent() {
        return this.spec.intent;
    }
    title(title) {
        return this.clone({ title });
    }
    getTitle() {
        return this.spec.title;
    }
    group(group) {
        return this.clone({ group });
    }
    getGroup() {
        return this.spec.group;
    }
    icon(icon) {
        return this.clone({ icon });
    }
    getIcon() {
        return this.spec.icon;
    }
    params(params) {
        return this.clone({ params });
    }
    getParams() {
        return this.spec.params;
    }
    showAsAction(showAsAction) {
        return this.clone({ showAsAction });
    }
    getShowAsAction() {
        return this.spec.showAsAction;
    }
    serialize(options = { path: [] }) {
        const { title, action, intent } = this.spec;
        if (!title) {
            const hint = typeof action === 'string' ? `action: "${action}"` : undefined;
            throw new SerializeError_1.SerializeError('`title` is required for menu item', options.path, options.index, hint).withHelpUrl(SerializeError_1.HELP_URL.TITLE_REQUIRED);
        }
        if (!action && !intent) {
            throw new SerializeError_1.SerializeError(`\`action\` or \`intent\` required for menu item with title ${this.spec.title}`, options.path, options.index, `"${title}"`).withHelpUrl(SerializeError_1.HELP_URL.ACTION_OR_INTENT_REQUIRED);
        }
        if (intent && action) {
            throw new SerializeError_1.SerializeError('cannot set both `action` AND `intent`', options.path, options.index, `"${title}"`).withHelpUrl(SerializeError_1.HELP_URL.ACTION_AND_INTENT_MUTUALLY_EXCLUSIVE);
        }
        return Object.assign({}, this.spec, { title });
    }
    clone(withSpec) {
        const builder = new MenuItemBuilder();
        builder.spec = Object.assign({}, this.spec, (withSpec || {}));
        return builder;
    }
}
exports.MenuItemBuilder = MenuItemBuilder;
function getOrderingMenuItem(ordering, extendedProjection) {
    return new MenuItemBuilder()
        .group('sorting')
        .title(`Sort by ${ordering.title}`)
        .icon(SortIcon)
        .action('setSortOrder')
        .params({ by: ordering.by, extendedProjection });
}
exports.getOrderingMenuItem = getOrderingMenuItem;
function getOrderingMenuItemsForSchemaType(typeName) {
    const type = typeof typeName === 'string' ? Schema_1.defaultSchema.get(typeName) : typeName;
    return (type.orderings
        ? type.orderings.concat(Sort_1.DEFAULT_ORDERING_OPTIONS)
        : Sort_1.DEFAULT_ORDERING_OPTIONS).map((ordering) => getOrderingMenuItem(ordering, getExtendedProjection_1.getExtendedProjection(type, ordering.by)));
}
exports.getOrderingMenuItemsForSchemaType = getOrderingMenuItemsForSchemaType;

//# sourceMappingURL=MenuItem.js.map
