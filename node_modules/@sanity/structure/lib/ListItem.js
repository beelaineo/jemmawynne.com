"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const lodash_1 = require("lodash");
const Schema_1 = require("./parts/Schema");
const DocumentList_1 = require("./DocumentList");
const SerializeError_1 = require("./SerializeError");
const List_1 = require("./List");
const Editor_1 = require("./Editor");
const Component_1 = require("./Component");
class ListItemBuilder {
    constructor(spec) {
        this.spec = spec ? spec : {};
    }
    id(id) {
        return this.clone({ id });
    }
    getId() {
        return this.spec.id;
    }
    title(title) {
        return this.clone({ title, id: this.spec.id || lodash_1.camelCase(title) });
    }
    getTitle() {
        return this.spec.title;
    }
    icon(icon) {
        return this.clone({ icon });
    }
    showIcon(enabled) {
        return this.clone({
            displayOptions: Object.assign({}, (this.spec.displayOptions || {}), { showIcon: enabled })
        });
    }
    getShowIcon() {
        return this.spec.displayOptions ? this.spec.displayOptions.showIcon : undefined;
    }
    getIcon() {
        return this.spec.icon;
    }
    child(child) {
        return this.clone({ child });
    }
    getChild() {
        return this.spec.child;
    }
    schemaType(schemaType) {
        return this.clone({ schemaType });
    }
    getSchemaType() {
        return this.spec.schemaType;
    }
    serialize(options = { path: [] }) {
        const { id, title, child } = this.spec;
        if (typeof id !== 'string' || !id) {
            throw new SerializeError_1.SerializeError('`id` is required for list items', options.path, options.index).withHelpUrl(SerializeError_1.HELP_URL.ID_REQUIRED);
        }
        if (!options.titleIsOptional && (typeof title !== 'string' || !title)) {
            throw new SerializeError_1.SerializeError('`title` is required for list items', options.path, id).withHelpUrl(SerializeError_1.HELP_URL.TITLE_REQUIRED);
        }
        let schemaType = this.spec.schemaType;
        if (typeof schemaType === 'string') {
            const type = Schema_1.defaultSchema.get(schemaType);
            if (!type) {
                throw new SerializeError_1.SerializeError(`Could not find type "${schemaType}" in schema`, options.path, id).withHelpUrl(SerializeError_1.HELP_URL.SCHEMA_TYPE_NOT_FOUND);
            }
            schemaType = type;
        }
        const serializeOptions = { path: options.path.concat(id), hint: 'child' };
        let listChild = child instanceof Component_1.ComponentBuilder ||
            child instanceof DocumentList_1.DocumentListBuilder ||
            child instanceof List_1.ListBuilder ||
            child instanceof Editor_1.EditorBuilder
            ? child.serialize(serializeOptions)
            : child;
        // In the case of a function, create a bound version that will pass the correct serialize
        // context, so we may lazily resolve it at some point in the future without losing context
        if (typeof listChild === 'function') {
            const originalChild = listChild;
            listChild = (itemId, options) => {
                return originalChild(itemId, Object.assign({}, options, { serializeOptions }));
            };
        }
        return Object.assign({}, this.spec, { schemaType, child: listChild, id, title, type: 'listItem' });
    }
    clone(withSpec) {
        const builder = new ListItemBuilder();
        builder.spec = Object.assign({}, this.spec, (withSpec || {}));
        return builder;
    }
}
exports.ListItemBuilder = ListItemBuilder;

//# sourceMappingURL=ListItem.js.map
