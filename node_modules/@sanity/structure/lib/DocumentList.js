"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const Client_1 = require("./parts/Client");
const Editor_1 = require("./Editor");
const SerializeError_1 = require("./SerializeError");
const GenericList_1 = require("./GenericList");
const resolveTypeForDocument = (id) => {
    const query = '*[_id in [$documentId, $draftId]]._type';
    const documentId = id.replace(/^drafts\./, '');
    const draftId = `drafts.${documentId}`;
    return Client_1.client.fetch(query, { documentId, draftId }).then(types => types[0]);
};
const validateFilter = (spec, options) => {
    const filter = spec.options.filter.trim();
    if (['*', '{'].includes(filter[0])) {
        throw new SerializeError_1.SerializeError(`\`filter\` cannot start with \`${filter[0]}\` - looks like you are providing a query, not a filter`, options.path, spec.id, spec.title).withHelpUrl(SerializeError_1.HELP_URL.QUERY_PROVIDED_FOR_FILTER);
    }
    return filter;
};
const resolveEditorChildForItem = (itemId, options) => {
    const parentItem = options.parent;
    return Promise.resolve(parentItem.schemaTypeName || resolveTypeForDocument(itemId)).then(type => new Editor_1.EditorBuilder()
        .id('editor')
        .documentId(itemId)
        .schemaType(type || ''));
};
class DocumentListBuilder extends GenericList_1.GenericListBuilder {
    constructor(spec) {
        super();
        this.spec = spec ? spec : {};
    }
    filter(filter) {
        return this.clone({ options: Object.assign({}, (this.spec.options || {}), { filter }) });
    }
    getFilter() {
        return this.spec.options && this.spec.options.filter;
    }
    schemaType(type) {
        return this.clone({ schemaTypeName: typeof type === 'string' ? type : type.name });
    }
    getSchemaType() {
        return this.spec.schemaTypeName;
    }
    params(params) {
        return this.clone({ options: Object.assign({}, (this.spec.options || { filter: '' }), { params }) });
    }
    getParams() {
        return this.spec.options && this.spec.options.params;
    }
    defaultOrdering(ordering) {
        if (!Array.isArray(ordering)) {
            throw new Error('`defaultOrdering` must be an array of order clauses');
        }
        return this.clone({
            options: Object.assign({}, (this.spec.options || { filter: '' }), { defaultOrdering: ordering })
        });
    }
    getDefaultOrdering() {
        return this.spec.options && this.spec.options.defaultOrdering;
    }
    serialize(options = { path: [] }) {
        if (typeof this.spec.id !== 'string' || !this.spec.id) {
            throw new SerializeError_1.SerializeError('`id` is required for document lists', options.path, options.index, this.spec.title).withHelpUrl(SerializeError_1.HELP_URL.ID_REQUIRED);
        }
        if (!this.spec.options || !this.spec.options.filter) {
            throw new SerializeError_1.SerializeError('`filter` is required for document lists', options.path, this.spec.id, this.spec.title).withHelpUrl(SerializeError_1.HELP_URL.FILTER_REQUIRED);
        }
        return Object.assign({}, super.serialize(options), { type: 'documentList', schemaTypeName: this.spec.schemaTypeName, child: this.spec.child || resolveEditorChildForItem, options: Object.assign({}, this.spec.options, { filter: validateFilter(this.spec, options) }) });
    }
    clone(withSpec) {
        const builder = new DocumentListBuilder();
        builder.spec = Object.assign({}, this.spec, (withSpec || {}));
        return builder;
    }
}
exports.DocumentListBuilder = DocumentListBuilder;

//# sourceMappingURL=DocumentList.js.map
