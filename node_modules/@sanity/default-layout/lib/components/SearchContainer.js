"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isHotkey = require("is-hotkey");

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _schema = _interopRequireDefault(require("part:@sanity/base/schema?"));

var _preview = _interopRequireDefault(require("part:@sanity/base/preview?"));

var _rxjs = require("rxjs");

var _operators = require("rxjs/operators");

var _router = require("part:@sanity/base/router");

var _search = _interopRequireDefault(require("part:@sanity/base/search"));

var _reactInk = _interopRequireDefault(require("react-ink"));

var _SearchField = _interopRequireDefault(require("./SearchField"));

var _SearchResults = _interopRequireDefault(require("./SearchResults"));

var _SearchResults2 = _interopRequireDefault(require("./styles/SearchResults.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var hotKeys = {
  // NOTE: Remove until we know what hotkey to use
  // openSearch: isKeyHotkey('ctrl+t'),
  debugSearch: (0, _isHotkey.isKeyHotkey)('ctrl+shift+d')
};

var searchOrEmpty = queryStr => {
  return queryStr === '' ? (0, _rxjs.of)([]) : (0, _search.default)(queryStr);
};

class SearchContainer extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "fieldRef", _react.default.createRef());

    _defineProperty(this, "resultsRef", _react.default.createRef());

    _defineProperty(this, "searchTerm$", new _rxjs.Subject());

    _defineProperty(this, "componentWillUnmount$", new _rxjs.Subject());

    _defineProperty(this, "state", {
      activeIndex: -1,
      error: null,
      isBleeding: true,
      // mobile first
      isFocused: false,
      isLoading: false,
      isPressing: false,
      results: [],
      value: '',
      isDebug: false
    });

    _defineProperty(this, "handleInputChange", event => {
      this.searchTerm$.next(event.currentTarget.value);
    });

    _defineProperty(this, "handleBlur", () => {
      if (!this.state.isPressing) {
        this.props.onClose();
        this.setState({
          isFocused: false
        });
      }
    });

    _defineProperty(this, "handleFocus", () => {
      this.props.onOpen();
      this.setState({
        isFocused: true
      });
    });

    _defineProperty(this, "handleHitMouseDown", event => {
      this.setState({
        activeIndex: Number(event.currentTarget.getAttribute('data-hit-index'))
      });
    });

    _defineProperty(this, "handleHitClick", event => {
      this.handleClear();
    });

    _defineProperty(this, "handleClear", () => {
      this.props.onClose();
      this.searchTerm$.next('');
      this.setState({
        isFocused: false
      });
    });

    _defineProperty(this, "handleKeyDown", event => {
      var _this$state = this.state,
          results = _this$state.results,
          activeIndex = _this$state.activeIndex;
      var isArrowKey = ['ArrowUp', 'ArrowDown'].includes(event.key);
      var lastIndex = results.length - 1;

      if (event.key === 'Enter') {
        var hitEl = this.resultsRef.current.element.querySelector("[data-hit-index=\"".concat(activeIndex, "\"]"));
        if (hitEl) hitEl.click();
      }

      if (event.key === 'Escape') {
        // this.handleClear()
        this.fieldRef.current.inputElement.blur();
      } // TODO: is it safe to remove this?
      // if (!isFocused && isArrowKey) {
      //   this.handleFocus()
      //   return
      // }


      if (isArrowKey) {
        event.preventDefault();
        var nextIndex = activeIndex + (event.key === 'ArrowUp' ? -1 : 1);

        if (nextIndex < 0) {
          nextIndex = lastIndex;
        }

        if (nextIndex > lastIndex) {
          nextIndex = 0;
        }

        this.setState({
          activeIndex: nextIndex
        });
      }
    });

    _defineProperty(this, "handleMouseDown", () => {
      this.setState({
        isPressing: true
      });
    });

    _defineProperty(this, "handleWindowKeyDown", event => {
      if (hotKeys.debugSearch(event)) {
        this.setState(prevState => ({
          isDebug: !prevState.isDebug
        }));
      }
    });

    _defineProperty(this, "handleWindowResize", () => {
      var isBleeding = !window.matchMedia('all and (min-width: 32em)').matches;
      this.setState({
        isBleeding
      });
    });

    _defineProperty(this, "handleWindowMouseUp", () => {
      this.setState({
        isPressing: false
      });
    });

    _defineProperty(this, "wrapWithDebug", (item, children) => {
      var isDebug = this.state.isDebug;

      if (!isDebug) {
        return children;
      }

      var stories = item.stories,
          score = item.score;
      return _react.default.createElement("div", {
        style: {
          border: '1px solid #aaa'
        }
      }, _react.default.createElement("div", {
        style: {
          padding: 4,
          fontSize: '90%',
          backgroundColor: '#f0f0f0'
        }
      }, _react.default.createElement("strong", null, "Total score: ", Math.round(score * 100) / 100), _react.default.createElement("ul", null, stories.filter(story => story.score > 0).map((story, i) => _react.default.createElement("li", {
        key: i
      }, story.path, ": ", story.score, " (", story.why, ")")))), children);
    });

    _defineProperty(this, "renderItem", (item, index, className) => {
      var hit = item.hit;

      var type = _schema.default.get(hit._type);

      return _react.default.createElement(_router.IntentLink, {
        className: className,
        intent: "edit",
        params: {
          id: hit._id,
          type: type.name
        },
        "data-hit-index": index,
        onMouseDown: this.handleHitMouseDown,
        onClick: this.handleHitClick,
        tabIndex: -1
      }, this.wrapWithDebug(item, _react.default.createElement(_preview.default, {
        value: hit,
        layout: "default",
        type: type,
        status: _react.default.createElement("div", {
          className: _SearchResults2.default.itemType
        }, type.title)
      })), _react.default.createElement(_reactInk.default, {
        duration: 200,
        opacity: 0.1,
        radius: 200
      }));
    });
  }

  componentDidMount() {
    window.addEventListener('keydown', this.handleWindowKeyDown);
    window.addEventListener('mouseup', this.handleWindowMouseUp);
    window.addEventListener('resize', this.handleWindowResize);
    this.searchTerm$.pipe((0, _operators.distinctUntilChanged)(), (0, _operators.switchMap)(queryStr => (0, _rxjs.concat)((0, _rxjs.of)({
      activeIndex: -1,
      error: null,
      value: queryStr,
      isLoading: true
    }), (0, _rxjs.timer)(100).pipe((0, _operators.mergeMapTo)(searchOrEmpty(queryStr)), (0, _operators.map)(results => ({
      results,
      isLoading: false
    }))))), // catch any error
    (0, _operators.catchError)((error, caught$) => (0, _rxjs.concat)((0, _rxjs.of)({
      error
    }), caught$)), (0, _operators.tap)(nextState => this.setState(nextState)), (0, _operators.takeUntil)(this.componentWillUnmount$.asObservable())).subscribe(); // trigger initial resize

    this.handleWindowResize();
  }

  componentDidUpdate(prevProps) {
    if (!prevProps.shouldBeFocused && this.props.shouldBeFocused) {
      this.fieldRef.current.inputElement.select();
    }
  }

  componentWillUnmount() {
    window.removeEventListener('mouseup', this.handleWindowMouseUp);
    window.removeEventListener('keydown', this.handleWindowKeyDown);
    window.removeEventListener('resize', this.handleWindowResize);
    this.componentWillUnmount$.next();
    this.componentWillUnmount$.complete();
  }

  renderResults() {
    var _this$state2 = this.state,
        activeIndex = _this$state2.activeIndex,
        error = _this$state2.error,
        isBleeding = _this$state2.isBleeding,
        isLoading = _this$state2.isLoading,
        results = _this$state2.results,
        value = _this$state2.value;
    return _react.default.createElement(_SearchResults.default, {
      activeIndex: activeIndex,
      error: error,
      isBleeding: isBleeding,
      isLoading: isLoading,
      items: results,
      query: value,
      renderItem: this.renderItem,
      ref: this.resultsRef
    });
  }

  render() {
    var _this$state3 = this.state,
        isBleeding = _this$state3.isBleeding,
        isFocused = _this$state3.isFocused,
        isLoading = _this$state3.isLoading,
        value = _this$state3.value;
    var isOpen = isFocused && value.length > 0;
    return _react.default.createElement(_SearchField.default, {
      isBleeding: isBleeding,
      isFocused: isFocused,
      isLoading: isLoading,
      isOpen: isOpen,
      onBlur: this.handleBlur,
      onChange: this.handleInputChange,
      onClear: this.handleClear,
      onFocus: this.handleFocus,
      onKeyDown: this.handleKeyDown,
      onMouseDown: this.handleMouseDown,
      ref: this.fieldRef,
      results: this.renderResults(),
      value: value
    });
  }

}

_defineProperty(SearchContainer, "propTypes", {
  onOpen: _propTypes.default.func.isRequired,
  onClose: _propTypes.default.func.isRequired,
  shouldBeFocused: _propTypes.default.bool.isRequired
});

var _default = SearchContainer;
exports.default = _default;