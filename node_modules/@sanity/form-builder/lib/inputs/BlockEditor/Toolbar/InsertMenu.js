"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _dropdown = _interopRequireDefault(require("part:@sanity/components/buttons/dropdown"));

var _blockObjectIcon = _interopRequireDefault(require("part:@sanity/base/block-object-icon"));

var _inlineObjectIcon = _interopRequireDefault(require("part:@sanity/base/inline-object-icon"));

var _paths = require("@sanity/util/paths");

var _InsertMenu = _interopRequireDefault(require("./styles/InsertMenu.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class InsertMenu extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "renderItem", item => {
      var Icon = item.icon;
      return _react.default.createElement("div", {
        className: _InsertMenu.default.item
      }, Icon && _react.default.createElement("div", {
        className: _InsertMenu.default.icon
      }, _react.default.createElement(Icon, null)), item.title);
    });

    _defineProperty(this, "getIcon", (type, fallbackIcon) => {
      return type.icon || type.type && type.type.icon || fallbackIcon;
    });

    _defineProperty(this, "handleOnAction", item => {
      var _this$props = this.props,
          onFocus = _this$props.onFocus,
          editor = _this$props.editor;
      var focusPath;

      if (item.isInline) {
        editor.command('insertInlineObject', {
          objectType: item.value
        });
        focusPath = [{
          _key: editor.value.focusBlock.key
        }, 'children', {
          _key: editor.value.focusInline.key
        }, _paths.FOCUS_TERMINATOR];
      } else {
        editor.command('insertBlockObject', {
          objectType: item.value
        });
        focusPath = [{
          _key: editor.value.focusBlock.key
        }, _paths.FOCUS_TERMINATOR];
      }

      setTimeout(() => onFocus(focusPath), 200);
    });
  }

  shouldComponentUpdate(nextProps) {
    return this.props.blockTypes !== nextProps.blockTypes || this.props.inlineTypes !== nextProps.inlineTypes || this.props.editorValue.focusBlock !== nextProps.editorValue.focusBlock;
  }

  getItems() {
    var editor = this.props.editor;
    var focusBlock = editor.value.focusBlock;
    var blockItems = this.props.blockTypes.map(type => ({
      title: type.title,
      value: type,
      icon: this.getIcon(type, _blockObjectIcon.default),
      isInline: false,
      isDisabled: false
    }));
    var inlineItems = this.props.inlineTypes.map(type => ({
      title: type.title,
      icon: this.getIcon(type, _inlineObjectIcon.default),
      value: type,
      isInline: true,
      isDisabled: focusBlock ? editor.query('isVoid', focusBlock) : true
    }));
    return blockItems.concat(inlineItems);
  }

  render() {
    return _react.default.createElement(_dropdown.default, {
      items: this.getItems(),
      renderItem: this.renderItem,
      onAction: this.handleOnAction,
      kind: "simple"
    }, "Insert");
  }

}

exports.default = InsertMenu;