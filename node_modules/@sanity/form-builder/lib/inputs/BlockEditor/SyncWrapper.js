"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _debounce2 = _interopRequireDefault(require("lodash/debounce"));

var _react = _interopRequireDefault(require("react"));

var _rxjs = require("rxjs");

var _blockTools = require("@sanity/block-tools");

var _generateHelpUrl = _interopRequireDefault(require("@sanity/generate-help-url"));

var _immutable = require("immutable");

var _default2 = _interopRequireDefault(require("part:@sanity/components/formfields/default"));

var _withPatchSubscriber = _interopRequireDefault(require("../../utils/withPatchSubscriber"));

var _PatchEvent = require("../../PatchEvent");

var _InvalidValueInput = _interopRequireDefault(require("../InvalidValueInput"));

var _resolveTypeName = require("../../utils/resolveTypeName");

var _createEditorController = _interopRequireDefault(require("./utils/createEditorController"));

var _Input = _interopRequireDefault(require("./Input"));

var _buildEditorSchema = _interopRequireDefault(require("./utils/buildEditorSchema"));

var _createOperationToPatches = _interopRequireDefault(require("./utils/createOperationToPatches"));

var _createPatchToOperations = _interopRequireDefault(require("./utils/createPatchToOperations"));

var _deserialize = _interopRequireDefault(require("./utils/deserialize"));

var _isWritingTextOperation = _interopRequireDefault(require("./utils/isWritingTextOperation"));

var _SyncWrapper = _interopRequireDefault(require("./styles/SyncWrapper.css"));

var _operators = require("rxjs/operators");

var _class, _temp;

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function findBlockType(type) {
  return type.of && type.of.find(ofType => ofType.name === 'block');
}

function isDeprecatedBlockSchema(type) {
  var blockType = findBlockType(type);

  if (blockType) {
    if (blockType.span !== undefined) {
      return 'deprecatedSpan';
    }

    if (type.of && type.of.find(memberType => memberType.options && memberType.options.inline)) {
      return 'deprecatedInline';
    }
  }

  return false;
}

function isDeprecatedBlockValue(value) {
  if (!value || !Array.isArray(value)) {
    return false;
  }

  var block = value.find(item => item._type === 'block');

  if (block && Object.keys(block).includes('spans')) {
    return true;
  }

  return false;
}

function isInvalidBlockValue(value) {
  if (Array.isArray(value)) {
    return false;
  }

  if (typeof value === 'undefined') {
    return false;
  }

  return true;
}

var _default = (0, _withPatchSubscriber.default)((_temp = _class = class SyncWrapper extends _react.default.Component {
  constructor(_props) {
    var _this;

    super(_props);
    _this = this;

    _defineProperty(this, "_unsubscribePatches", void 0);

    _defineProperty(this, "_changeSubscription", void 0);

    _defineProperty(this, "_input", null);

    _defineProperty(this, "_undoRedoStack", {
      undo: [],
      redo: []
    });

    _defineProperty(this, "_controller", void 0);

    _defineProperty(this, "_blockContentFeatures", void 0);

    _defineProperty(this, "_pendingLocalChanges", []);

    _defineProperty(this, "operationToPatches", void 0);

    _defineProperty(this, "patchToOperations", void 0);

    _defineProperty(this, "localChanges$", new _rxjs.Subject());

    _defineProperty(this, "remoteChanges$", new _rxjs.Subject());

    _defineProperty(this, "changes$", this.localChanges$.pipe((0, _operators.merge)(this.remoteChanges$)));

    _defineProperty(this, "handleEditorChange", (editor, callback) => {
      var operations = editor.operations,
          value = editor.value;
      var selection = value.selection;
      this.localChanges$.next({
        operations,
        isRemote: false,
        selection,
        callback
      });
      var userIsWritingText = (0, _isWritingTextOperation.default)(operations);

      if (userIsWritingText) {
        this.setState({
          userIsWritingText: true
        });
        this.unsetUserIsWritingTextDebounced();
      }
    });

    _defineProperty(this, "handleChangeSet", changeSet => {
      var operations = changeSet.operations,
          isRemote = changeSet.isRemote,
          selection = changeSet.selection,
          callback = changeSet.callback; // Add undo step for local changes

      if (!isRemote && !operations.some(op => op.__isUndoRedo) && !operations.every(op => op.type === 'set_selection') && !operations.every(op => op.type === 'set_value')) {
        this._undoRedoStack.undo.push({
          operations,
          beforeSelection: this.state.editorValue.selection,
          afterSelection: selection,
          remoteOperations: (0, _immutable.List)([])
        });

        this._undoRedoStack.redo = [];
      } // Add all remote operations to undo/redo stack items
      // But not rebase changes (isRemote is then 'internal')


      if (isRemote === 'remote') {
        this._undoRedoStack.undo.forEach(item => {
          item.remoteOperations = item.remoteOperations.concat(operations);
        });

        this._undoRedoStack.redo.forEach(item => {
          item.remoteOperations = item.remoteOperations.concat(operations);
        });
      } // Run through and apply the incoming operations


      var localChangeGroups = [];

      if (isRemote === 'internal') {
        var rebaseOperations = operations.filter(op => op.type !== 'set_selection');
        var selectOperations = operations.filter(op => op.type === 'set_selection'); // Rebase events (replace the nodes) must not be done with normalization!

        this._controller.withoutNormalizing(() => {
          rebaseOperations.forEach(op => {
            this._controller.applyOperation(op);
          });
        }); // Restoring of selection should be done with normalization


        selectOperations.forEach(op => {
          this._controller.applyOperation(op);
        });
      } else {
        operations.forEach(op => {
          if (isRemote) {
            this._controller.applyOperation(op);
          } else {
            var _beforeValue = this._controller.value;

            try {
              this._controller.applyOperation(op);

              localChangeGroups.push({
                patches: this.operationToPatches(op, _beforeValue, this._controller.value, this.props.value),
                operation: op
              });
            } catch (err) {
              // Let's keep this console.log for a while (2018-12-19), if we end up here, there is something fishy going on!
              // eslint-disable-next-line no-console
              console.log("Got error trying to apply local operation. The error was '".concat(err.message, "' The operation was ").concat(JSON.stringify(op.toJSON()))); // Restore to current formbuilder value (but try to apply the last known selection)

              this.restoreCurrentValue(_beforeValue.selection);
            }
          }
        });
      } // Set the new state


      this.setState({
        editorValue: this._controller.value
      }, () => {
        if (localChangeGroups.length) {
          this._pendingLocalChanges.push((0, _flatten2.default)(localChangeGroups));

          this.sendLocalPatches();
        }

        if (callback) {
          return callback();
        }

        return true;
      });
    });

    _defineProperty(this, "sendLocalPatches", () => {
      var onChange = this.props.onChange;
      var cutLength = this._pendingLocalChanges.length;
      var finalPatches = (0, _flatten2.default)(this._pendingLocalChanges.map(changeGroup => (0, _flatten2.default)(changeGroup.map(change => change.patches)))); // Run through the pending patches and remove any redundant ones.

      finalPatches = finalPatches.filter((patch, index) => {
        if (!patch) {
          return false;
        }

        var nextPatch = finalPatches[index + 1];

        if (nextPatch && nextPatch.type === 'set' && patch.type === 'set' && (0, _isEqual2.default)(patch.path, nextPatch.path)) {
          return false;
        }

        return true;
      });

      if (finalPatches.length) {
        // Remove the processed patches
        this._pendingLocalChanges.splice(0, cutLength); // Send the final patches


        onChange(_PatchEvent.PatchEvent.from(finalPatches));
      }
    });

    _defineProperty(this, "unsetUserIsWritingTextDebounced", (0, _debounce2.default)(() => {
      this.setState({
        userIsWritingText: false
      });
    }, 1000));

    _defineProperty(this, "handleFormBuilderPatch", event => {
      var onChange = this.props.onChange;
      event.patches.forEach(patch => {
        var operations = this.patchToOperations(patch, this._controller.value);
        this.localChanges$.next({
          operations,
          editorValue: this._controller.value,
          isRemote: true
        });
      });
      return onChange(event);
    });

    _defineProperty(this, "handleDocumentPatches", (_ref) => {
      var patches = _ref.patches,
          shouldReset = _ref.shouldReset,
          snapshot = _ref.snapshot;

      if (patches.length === 0) {
        return;
      } // Handle remote (and internal) patches


      var remoteAndInternalPatches = patches.filter(patch => ['remote', 'internal'].includes(patch.origin));

      if (remoteAndInternalPatches.length > 0) {
        remoteAndInternalPatches.forEach(patch => {
          var operations = this.patchToOperations(patch, this._controller.value);
          this.remoteChanges$.next({
            operations,
            isRemote: patch.origin,
            patches: remoteAndInternalPatches
          });
        });
      }
    });

    _defineProperty(this, "handleOnLoading", function () {
      var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var loading = _this.state.loading;

      var _loading = _objectSpread({}, loading, props);

      var isLoading = Object.keys(_loading).some(key => _loading[key]);

      _this.setState({
        isLoading,
        loading: _loading
      });
    });

    _defineProperty(this, "handleInvalidValue", () => {});

    _defineProperty(this, "refInput", input => {
      this._input = input;
    });

    var _value = _props.value,
        type = _props.type;
    var deprecatedSchema = isDeprecatedBlockSchema(type);
    var deprecatedBlockValue = isDeprecatedBlockValue(_value);
    var invalidBlockValue = isInvalidBlockValue(_value);
    this.state = {
      deprecatedSchema,
      deprecatedBlockValue,
      invalidBlockValue,
      editorValue: null,
      isLoading: false,
      loading: {},
      userIsWritingText: false
    };
    var displayValue = null;

    try {
      displayValue = deprecatedSchema || deprecatedBlockValue || invalidBlockValue ? (0, _deserialize.default)([], type) : (0, _deserialize.default)(_value, type);
    } catch (err) {
      this.state.invalidBlockValue = true;
      displayValue = (0, _deserialize.default)([], type);
    }

    this._blockContentFeatures = (0, _blockTools.getBlockContentFeatures)(type);
    var editorSchema = (0, _buildEditorSchema.default)(this._blockContentFeatures);
    var controllerOpts = {
      value: displayValue,
      plugins: [{
        schema: editorSchema
      }]
    };
    this._controller = (0, _createEditorController.default)(controllerOpts);
    this.operationToPatches = (0, _createOperationToPatches.default)(this._blockContentFeatures, type);
    this.patchToOperations = (0, _createPatchToOperations.default)(this._blockContentFeatures, type);
    this.state.editorValue = this._controller.value; // Normalized value by editor schema

    this._unsubscribePatches = _props.subscribe(this.handleDocumentPatches);
    this._changeSubscription = this.changes$.subscribe(this.handleChangeSet);
  }

  componentWillUnmount() {
    this._unsubscribePatches();

    this._changeSubscription.unsubscribe();
  }

  restoreCurrentValue(lastKnownSelection) {
    this._controller.setValue((0, _deserialize.default)(this.props.value, this.props.type));

    if (lastKnownSelection) {
      this._controller.select(lastKnownSelection);
    }

    this.setState({
      editorValue: this._controller.value
    });
  }

  focus() {
    if (this._input) {
      this._input.focus();
    }
  }

  // eslint-disable-next-line complexity
  render() {
    var _this$state = this.state,
        editorValue = _this$state.editorValue,
        deprecatedSchema = _this$state.deprecatedSchema,
        deprecatedBlockValue = _this$state.deprecatedBlockValue,
        invalidBlockValue = _this$state.invalidBlockValue,
        isLoading = _this$state.isLoading,
        userIsWritingText = _this$state.userIsWritingText;
    var _this$props = this.props,
        focusPath = _this$props.focusPath,
        level = _this$props.level,
        markers = _this$props.markers,
        onBlur = _this$props.onBlur,
        onFocus = _this$props.onFocus,
        onPaste = _this$props.onPaste,
        readOnly = _this$props.readOnly,
        renderCustomMarkers = _this$props.renderCustomMarkers,
        renderBlockActions = _this$props.renderBlockActions,
        type = _this$props.type,
        value = _this$props.value;
    var isDeprecated = deprecatedSchema || deprecatedBlockValue;
    return _react.default.createElement("div", {
      className: _SyncWrapper.default.root
    }, !isDeprecated && !invalidBlockValue && _react.default.createElement(_Input.default, {
      blockContentFeatures: this._blockContentFeatures,
      controller: this._controller,
      editorValue: editorValue,
      focusPath: focusPath,
      isLoading: isLoading,
      level: level,
      markers: markers,
      onBlur: onBlur,
      onChange: this.handleEditorChange,
      onFocus: onFocus,
      onLoading: this.handleOnLoading,
      onPaste: onPaste,
      onPatch: this.handleFormBuilderPatch,
      readOnly: readOnly,
      ref: this.refInput,
      renderBlockActions: renderBlockActions,
      renderCustomMarkers: renderCustomMarkers,
      type: type,
      undoRedoStack: this._undoRedoStack,
      userIsWritingText: userIsWritingText,
      value: value
    }), invalidBlockValue && _react.default.createElement(_InvalidValueInput.default, {
      validTypes: type.of ? type.of.map(mType => mType.name) : [],
      actualType: (0, _resolveTypeName.resolveTypeName)(value),
      value: value,
      onChange: this.handleInvalidValue
    }), isDeprecated && _react.default.createElement(_default2.default, {
      label: type.title
    }, _react.default.createElement("div", {
      className: _SyncWrapper.default.disabledEditor
    }, _react.default.createElement("strong", null, "Heads up!"), _react.default.createElement("p", null, "You're using a new version of the Studio with", deprecatedSchema && " a block schema that hasn't been updated.", deprecatedSchema && deprecatedBlockValue && ' Also block text needs to be updated.', deprecatedBlockValue && !deprecatedSchema && " block text that hasn't been updated."), deprecatedSchema === 'deprecatedInline' && _react.default.createElement("p", null, _react.default.createElement("a", {
      href: (0, _generateHelpUrl.default)('migrate-to-block-inline-types'),
      rel: "noopener noreferrer",
      target: "_blank"
    }, "Migrate schema to block.children inline types")), deprecatedSchema === 'deprecatedSpan' && _react.default.createElement("p", null, _react.default.createElement("a", {
      href: (0, _generateHelpUrl.default)('migrate-to-block-children'),
      rel: "noopener noreferrer",
      target: "_blank"
    }, "Migrate schema to block.children")))));
  }

}, _defineProperty(_class, "defaultProps", {
  markers: []
}), _temp));

exports.default = _default;