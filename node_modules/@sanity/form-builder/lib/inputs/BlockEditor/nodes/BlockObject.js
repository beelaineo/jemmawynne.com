"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _reactDom = _interopRequireDefault(require("react-dom"));

var _slateBase64Serializer = _interopRequireDefault(require("slate-base64-serializer"));

var _react = _interopRequireWildcard(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _slateReact = require("slate-react");

var _slate = require("slate");

var _router = require("part:@sanity/base/router");

var _linkIcon = _interopRequireDefault(require("part:@sanity/base/link-icon"));

var _editIcon = _interopRequireDefault(require("part:@sanity/base/edit-icon"));

var _visibilityIcon = _interopRequireDefault(require("part:@sanity/base/visibility-icon"));

var _trashIcon = _interopRequireDefault(require("part:@sanity/base/trash-icon"));

var _dropdown = _interopRequireDefault(require("part:@sanity/components/buttons/dropdown"));

var _PatchEvent = require("../../../PatchEvent");

var _paths = require("@sanity/util/paths");

var _resolveTypeName = require("../../../utils/resolveTypeName");

var _InvalidValueInput = _interopRequireDefault(require("../../InvalidValueInput"));

var _Preview = _interopRequireDefault(require("../../../Preview"));

var _BlockObject = _interopRequireDefault(require("./styles/BlockObject.css"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class BlockObject extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_dropTarget", void 0);

    _defineProperty(this, "_editorNode", null);

    _defineProperty(this, "_dragGhost", null);

    _defineProperty(this, "previewContainer", void 0);

    _defineProperty(this, "state", {
      isDragging: false
    });

    _defineProperty(this, "handleDragStart", event => {
      var _this$props = this.props,
          node = _this$props.node,
          readOnly = _this$props.readOnly;

      if (readOnly) {
        event.preventDefault();
        return;
      }

      this.setState({
        isDragging: true
      });
      this.addDragHandlers();

      var encoded = _slateBase64Serializer.default.serializeNode(node, {
        preserveKeys: true,
        preserveData: true
      });

      (0, _slateReact.setEventTransfer)(event, 'node', encoded);
      event.dataTransfer.effectAllowed = 'move'; // Specify dragImage so that single elements in the preview will not be the drag image,
      // but always the whole block thing itself.
      // Also clone it so that it will not be visually clipped by scroll-containers etc.

      var element = event.currentTarget;

      if (element) {
        this._dragGhost = element.cloneNode(true);
        this._dragGhost.style.width = "".concat(element.clientWidth, "px");
        this._dragGhost.style.height = "".concat(element.clientHeight, "px");
        this._dragGhost.style.position = 'absolute';
        this._dragGhost.style.top = '-99999px';
        this._dragGhost.style.left = '-99999px';

        if (document.body) {
          document.body.appendChild(this._dragGhost); // eslint-disable-next-line max-depth

          if (this._dragGhost) {
            var rect = element.getBoundingClientRect();
            var x = event.clientX - rect.left;
            var y = event.clientY - rect.top;
            event.dataTransfer.setDragImage(this._dragGhost, x, y);
          }
        }
      }
    });

    _defineProperty(this, "handleDragLeave", event => {
      event.preventDefault();
      this.resetDropTarget();
    });

    _defineProperty(this, "handleDragOverOtherNode", // eslint-disable-next-line complexity
    event => {
      if (!this.state.isDragging) {
        return;
      }

      event.preventDefault();
      event.stopPropagation();
      var node = this.props.node;
      var targetDOMNode;

      if (event.target instanceof HTMLElement) {
        var keyNodes = event.target.querySelectorAll('[data-key]');
        targetDOMNode = keyNodes.item(0);
      } // As the event is registered on the editor parent node
      // ignore the event if it is coming from from the editor node itself


      if (!targetDOMNode || targetDOMNode === this._editorNode) {
        this.resetDropTarget();
        return;
      }

      if (event.dataTransfer) {
        event.dataTransfer.dropEffect = 'move';
      }

      var editor = this.props.editor;
      var targetNode = (0, _slateReact.findNode)(targetDOMNode, editor);

      if (!targetNode) {
        this.resetDropTarget();
        return;
      }

      var block = targetNode.object === 'block' ? targetNode : editor.value.document.getClosestBlock(targetNode.key); // If no or same block reset and return

      if (!block || block.key === node.key) {
        this.resetDropTarget();
        return;
      }

      var blockDOMNode = (0, _slateReact.findDOMNode)(block);
      var rect = blockDOMNode.getBoundingClientRect();
      var position = event.clientY < rect.top + blockDOMNode.scrollHeight / 2 ? 'before' : 'after'; // If the block in the nearest vincinity (same position target), reset and return

      var nearestNeighbour = false;

      if (position === 'before') {
        var nextBlock = editor.value.document.getNextBlock(node.key);
        nearestNeighbour = nextBlock && nextBlock.key === block.key;
      } else {
        var previousBlock = editor.value.document.getPreviousBlock(node.key);
        nearestNeighbour = previousBlock && previousBlock.key === block.key;
      }

      if (nearestNeighbour) {
        this.resetDropTarget();
        return;
      }

      this.props.onShowBlockDragMarker(position, blockDOMNode);
      this._dropTarget = {
        node: block,
        position
      };
    });

    _defineProperty(this, "handleDragEnd", event => {
      event.preventDefault();
      event.dataTransfer.dropEffect = 'move';
      this.setState({
        isDragging: false
      });
      var target = this._dropTarget;
      this.removeDragHandlers();
      this.resetDropTarget(); // Remove the ghost

      if (this._dragGhost && this._dragGhost.parentNode) {
        this._dragGhost.parentNode.removeChild(this._dragGhost);
      }

      var _this$props2 = this.props,
          node = _this$props2.node,
          editor = _this$props2.editor; // Return if this is our node

      if (!target || target.node.key === node.key) {
        return;
      }

      editor.removeNodeByKey(node.key)[target.position === 'before' ? 'moveToStartOfNode' : 'moveToEndOfNode'](target.node).insertBlock(node).moveToEndOfNode(node).focus();
    });

    _defineProperty(this, "handleCancelEvent", event => {
      event.preventDefault();
      event.stopPropagation();
    });

    _defineProperty(this, "handleFocus", event => {
      event.stopPropagation();
      var _this$props3 = this.props,
          node = _this$props3.node,
          onFocus = _this$props3.onFocus;
      onFocus([{
        _key: node.key
      }, _paths.FOCUS_TERMINATOR]);
    });

    _defineProperty(this, "handleDoubleClick", event => {
      var readOnly = this.props.readOnly;

      if (readOnly) {
        this.handleView();
        return;
      }

      this.handleEditStart();
    });

    _defineProperty(this, "handleEditStart", () => {
      var _this$props4 = this.props,
          node = _this$props4.node,
          onFocus = _this$props4.onFocus,
          editor = _this$props4.editor;
      editor.moveToEndOfNode(node).focus().blur();
      setTimeout(() => {
        onFocus([{
          _key: node.key
        }, _paths.FOCUS_TERMINATOR]);
      }, 100);
    });

    _defineProperty(this, "handleClose", () => {
      var _this$props5 = this.props,
          node = _this$props5.node,
          onFocus = _this$props5.onFocus;
      onFocus([{
        _key: node.key
      }]);
    });

    _defineProperty(this, "refPreview", previewContainer => {
      this.previewContainer = previewContainer;
    });

    _defineProperty(this, "handleInvalidValue", event => {
      var onPatch = this.props.onPatch;
      var value = this.getValue();
      onPatch(event.prefixAll({
        _key: value._key
      }), value);
    });

    _defineProperty(this, "handleHeaderMenuAction", item => {
      var _this$props6 = this.props,
          node = _this$props6.node,
          editor = _this$props6.editor;

      if (item.name === 'delete') {
        editor.removeNodeByKey(node.key).focus();
      }

      if (item.name === 'edit') {
        this.handleEditStart();
      }

      if (item.name === 'view') {
        this.handleView();
      }
    });

    _defineProperty(this, "handleView", () => {
      var _this$props7 = this.props,
          node = _this$props7.node,
          onFocus = _this$props7.onFocus;
      onFocus([{
        _key: node.key
      }, _paths.FOCUS_TERMINATOR]);
    });

    _defineProperty(this, "renderMenuItem", item => {
      var Icon = item.icon;
      return _react.default.createElement("div", {
        className: item.color === 'danger' ? _BlockObject.default.menuItemDanger : _BlockObject.default.menuItem
      }, item.intent ? _react.default.createElement(_router.IntentLink, {
        intent: item.intent,
        params: item.params
      }, Icon && _react.default.createElement(Icon, null), item.title) : _react.default.createElement(_react.Fragment, null, Icon && _react.default.createElement(Icon, null), "\xA0", item.title));
    });

    _defineProperty(this, "handleMouseDown", event => {
      this.props.editor.moveToEndOfNode(this.props.node);
    });

    _defineProperty(this, "renderPreview", value => {
      var _this$props8 = this.props,
          type = _this$props8.type,
          readOnly = _this$props8.readOnly;
      var menuItems = [];

      if (value._ref) {
        menuItems.push({
          title: 'Go to reference',
          icon: _linkIcon.default,
          intent: 'edit',
          params: {
            id: value._ref
          }
        });
      }

      if (readOnly) {
        menuItems.push({
          title: 'View',
          icon: _visibilityIcon.default,
          name: 'view'
        });
      } else {
        menuItems.push({
          title: 'Edit',
          icon: _editIcon.default,
          name: 'edit'
        });
        menuItems.push({
          title: 'Delete',
          name: 'delete',
          icon: _trashIcon.default,
          color: 'danger'
        });
      }

      return _react.default.createElement("div", {
        className: _BlockObject.default.preview
      }, _react.default.createElement(_Preview.default, {
        type: type,
        value: value,
        layout: "block"
      }), _react.default.createElement("div", {
        className: _BlockObject.default.header
      }, _react.default.createElement(_dropdown.default, {
        placement: "bottom-end",
        items: menuItems,
        onAction: this.handleHeaderMenuAction,
        renderItem: this.renderMenuItem
      }, type ? type.title || type.name : 'Unknown')));
    });

    _defineProperty(this, "handleInvalidTypeContainerClick", event => {
      event.preventDefault();
      event.stopPropagation();
    });
  }

  componentDidMount() {
    var editor = this.props.editor;

    var elm = _reactDom.default.findDOMNode(editor); // eslint-disable-line react/no-find-dom-node


    if (elm instanceof HTMLElement) {
      this._editorNode = elm;
    }
  }

  componentWillUnmount() {
    this.removeDragHandlers();
  }

  addDragHandlers() {
    var readOnly = this.props.readOnly;

    if (readOnly) {
      return;
    }

    if (this._editorNode) {
      this._editorNode.addEventListener('dragover', this.handleDragOverOtherNode);
    }

    if (this._editorNode) {
      this._editorNode.addEventListener('dragleave', this.handleDragLeave);
    }
  }

  removeDragHandlers() {
    if (this._editorNode) {
      this._editorNode.removeEventListener('dragover', this.handleDragOverOtherNode);
    }

    if (this._editorNode) {
      this._editorNode.removeEventListener('dragleave', this.handleDragLeave);
    }
  }

  resetDropTarget() {
    this._dropTarget = null;
    this.props.onHideBlockDragMarker();
  }

  getValue() {
    return this.props.node.data.get('value');
  }

  render() {
    var _this$props9 = this.props,
        attributes = _this$props9.attributes,
        blockContentFeatures = _this$props9.blockContentFeatures,
        editor = _this$props9.editor,
        isSelected = _this$props9.isSelected,
        markers = _this$props9.markers,
        node = _this$props9.node,
        readOnly = _this$props9.readOnly;
    var isDragging = this.state.isDragging;
    var value = this.getValue();
    var valueType = (0, _resolveTypeName.resolveTypeName)(value);
    var validTypes = blockContentFeatures.types.blockObjects.map(objType => objType.name).concat('block');

    if (!validTypes.includes(valueType)) {
      return _react.default.createElement("div", _extends({}, attributes, {
        onClick: this.handleInvalidTypeContainerClick,
        contentEditable: false
      }), _react.default.createElement(_InvalidValueInput.default, {
        validTypes: validTypes,
        actualType: valueType,
        value: value,
        onChange: this.handleInvalidValue
      }));
    }

    var validation = markers.filter(marker => marker.type === 'validation');
    var errors = validation.filter(marker => marker.level === 'error');
    var classname = (0, _classnames.default)([_BlockObject.default.root, editor.value.selection.focus.isInNode(node) && _BlockObject.default.focused, isSelected && _BlockObject.default.selected, errors.length > 0 && _BlockObject.default.hasErrors, isDragging && _BlockObject.default.isDragging]);
    return _react.default.createElement("div", attributes, _react.default.createElement("div", {
      onDragStart: this.handleDragStart,
      onDragEnd: this.handleDragEnd,
      onDragEnter: this.handleCancelEvent,
      onDragLeave: this.handleCancelEvent,
      onDrop: this.handleCancelEvent,
      onDoubleClick: this.handleDoubleClick,
      onMouseDown: this.handleMouseDown,
      draggable: !readOnly,
      className: classname
    }, _react.default.createElement("div", {
      ref: this.refPreview,
      className: _BlockObject.default.previewContainer,
      style: readOnly ? {
        cursor: 'default'
      } : {}
    }, this.renderPreview(value))));
  }

}

exports.default = BlockObject;

_defineProperty(BlockObject, "defaultProps", {
  blockActions: null,
  renderCustomMarkers: null,
  isSelected: false
});