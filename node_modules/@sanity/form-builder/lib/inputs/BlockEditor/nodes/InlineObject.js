"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _throttle2 = _interopRequireDefault(require("lodash/throttle"));

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _reactDom = _interopRequireDefault(require("react-dom"));

var _slateBase64Serializer = _interopRequireDefault(require("slate-base64-serializer"));

var _react = _interopRequireDefault(require("react"));

var _classnames = _interopRequireDefault(require("classnames"));

var _resolveTypeName = require("../../../utils/resolveTypeName");

var _PatchEvent = require("../../../PatchEvent");

var _paths = require("@sanity/util/paths");

var _InvalidValueInput = _interopRequireDefault(require("../../InvalidValueInput"));

var _Preview = _interopRequireDefault(require("../../../Preview"));

var _InlineObject = _interopRequireDefault(require("./styles/InlineObject.css"));

var _slate = require("slate");

var _slateReact = require("slate-react");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class InlineObject extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "_dropTarget", null);

    _defineProperty(this, "_editorNode", null);

    _defineProperty(this, "_previewContainer", null);

    _defineProperty(this, "state", {
      isDragging: false
    });

    _defineProperty(this, "handleDragStart", event => {
      var node = this.props.node;
      this.setState({
        isDragging: true
      });
      this.addDragHandlers();

      var element = _reactDom.default.findDOMNode(this._previewContainer); // eslint-disable-line react/no-find-dom-node


      if (element && element instanceof HTMLElement) {
        var encoded = _slateBase64Serializer.default.serializeNode(node, {
          preserveKeys: true
        });

        (0, _slateReact.setEventTransfer)(event, 'node', encoded);
        event.dataTransfer.effectAllowed = 'move';
        event.dataTransfer.setDragImage(element, element.clientWidth / 2, -10);
      }

      this.props.editor.moveToEndOfNode(this.props.node).focus();
    });

    _defineProperty(this, "handleDragLeave", event => {
      // must not be .currentTarget!
      if (event.target === this._editorNode) {
        this.resetDropTarget();
      }
    });

    _defineProperty(this, "handleDragOverOtherNode", event => {
      if (!this.state.isDragging) {
        return;
      }

      var targetDOMNode = event.target; // Must not be .currentTarget!
      // As the event is registered on the editor parent node
      // ignore the event if it is coming from from the editor node itself

      if (targetDOMNode === this._editorNode) {
        this.restoreSelection();
        return;
      }

      var editor = this.props.editor;
      var range = (0, _slateReact.getEventRange)(event, editor);

      if (range === null || range.focus && range.focus.offset === undefined) {
        this.restoreSelection();
        return;
      }

      var targetNode = editor.value.document.getDescendant(range.focus.key); // If we are dragging over another inline return

      if (editor.value.document.getClosestInline(targetNode.key)) {
        this.restoreSelection();
        return;
      } // If we are dragging over a custom type block return


      var block = editor.value.document.getClosestBlock(range.focus.key);

      if (block && block.type !== 'contentBlock') {
        return;
      }

      this.moveCursor(range, targetNode);
    });

    _defineProperty(this, "moveCursor", (0, _throttle2.default)((range, node) => {
      var editor = this.props.editor;
      var theOffset = range.focus.offset; // Check if it is acceptable to move the cursor here

      var texts = editor.value.document.getTextsAtRange(_slate.Range.create({
        anchor: {
          key: node.key,
          offset: theOffset - 1
        },
        focus: {
          key: node.key,
          offset: theOffset
        }
      }));

      if (!texts.size) {
        theOffset = 0;
      }

      return editor.withoutSaving(() => {
        editor.moveToStartOfNode(node).moveForward(theOffset).focus();
        var selection = editor.value.selection;

        if (!this._dropTarget || range.focus.offset !== this._dropTarget.selection.focus.offset) {
          this._dropTarget = {
            node: node,
            selection
          };
        }

        return editor;
      });
    }, 30));

    _defineProperty(this, "handleDragEnd", event => {
      this.setState({
        isDragging: false
      });
      var _this$props = this.props,
          node = _this$props.node,
          editor = _this$props.editor;
      var target = this._dropTarget; // Return if this is our node

      if (!target || target.node === node) {
        this.resetDropTarget();
        return;
      }

      editor.select(target.selection).removeNodeByKey(node.key);
      var _editor$value = editor.value,
          focusBlock = _editor$value.focusBlock,
          focusText = _editor$value.focusText; // Create a new key for the "new" object

      var newNode = node.toJSON({
        preserveKeys: true,
        perserveData: true
      });
      var newKey = "".concat(focusBlock.key).concat(focusBlock.nodes.indexOf(focusText) + 1);
      newNode.data.value._key = newKey;
      newNode.data._key = newKey;
      newNode.key = newKey;
      newNode = _slate.Inline.create(newNode);
      editor.insertInline(newNode);
      this.resetDropTarget();
    });

    _defineProperty(this, "handleInvalidValue", event => {
      var _event = event;
      var _this$props2 = this.props,
          editor = _this$props2.editor,
          onPatch = _this$props2.onPatch;
      var value = this.getValue();
      var parentBlock = editor.value.document.getClosestBlock(value._key);
      var path = [{
        _key: parentBlock.key
      }, 'children', {
        _key: value._key
      }];
      path.reverse().forEach(part => {
        _event = _event.prefixAll(part);
      });
      onPatch(_event, value);
    });

    _defineProperty(this, "handleCancelEvent", event => {
      event.stopPropagation();
      event.preventDefault();
    });

    _defineProperty(this, "handleEditStart", event => {
      event.stopPropagation();
      var _this$props3 = this.props,
          editor = _this$props3.editor,
          node = _this$props3.node,
          onFocus = _this$props3.onFocus;
      editor.blur();
      editor.moveToEndOfNode(node).focus().blur();
      var block = editor.value.focusBlock;
      setTimeout(() => {
        onFocus([{
          _key: block.key
        }, 'children', {
          _key: node.key
        }, _paths.FOCUS_TERMINATOR]);
      }, 100);
    });

    _defineProperty(this, "handleView", () => {
      var _this$props4 = this.props,
          editor = _this$props4.editor,
          node = _this$props4.node,
          onFocus = _this$props4.onFocus;
      onFocus([{
        _key: editor.value.document.getParent(node.key).key
      }, 'children', {
        _key: node.key
      }, _paths.FOCUS_TERMINATOR]);
    });

    _defineProperty(this, "refPreviewContainer", elm => {
      this._previewContainer = elm;
    });

    _defineProperty(this, "handleInvalidTypeContainerClick", event => {
      event.preventDefault();
      event.stopPropagation();
    });
  }

  componentDidMount() {
    var editor = this.props.editor;

    var elm = _reactDom.default.findDOMNode(editor); // eslint-disable-line react/no-find-dom-node


    if (elm instanceof HTMLElement) {
      this._editorNode = elm;
    }
  }

  componentWillUnmount() {
    this.removeDragHandlers();
  }

  addDragHandlers() {
    if (this._editorNode) {
      this._editorNode.addEventListener('dragover', this.handleDragOverOtherNode);
    }

    if (this._editorNode) {
      this._editorNode.addEventListener('dragleave', this.handleDragLeave);
    }
  }

  removeDragHandlers() {
    if (this._editorNode) {
      this._editorNode.removeEventListener('dragover', this.handleDragOverOtherNode);
    }

    if (this._editorNode) {
      this._editorNode.removeEventListener('dragleave', this.handleDragLeave);
    }
  }

  resetDropTarget() {
    this._dropTarget = null;
  }

  restoreSelection() {
    var editor = this.props.editor;
    editor.withoutSaving(() => {
      editor.moveToEndOfNode(this.props.node).focus();
    });
    this.resetDropTarget();
  }

  getValue() {
    return this.props.node.data.get('value');
  }

  // eslint-disable-next-line complexity
  render() {
    var _this$props5 = this.props,
        attributes = _this$props5.attributes,
        blockContentFeatures = _this$props5.blockContentFeatures,
        editor = _this$props5.editor,
        isSelected = _this$props5.isSelected,
        markers = _this$props5.markers,
        node = _this$props5.node,
        readOnly = _this$props5.readOnly,
        type = _this$props5.type;
    var value = this.getValue();
    var valueType = (0, _resolveTypeName.resolveTypeName)(value);
    var validTypes = blockContentFeatures.types.inlineObjects.map(objType => objType.name);

    if (!validTypes.includes(valueType)) {
      return _react.default.createElement("div", _extends({}, attributes, {
        onClick: this.handleInvalidTypeContainerClick,
        contentEditable: false
      }), _react.default.createElement(_InvalidValueInput.default, {
        validTypes: validTypes,
        actualType: valueType,
        value: value,
        onChange: this.handleInvalidValue
      }));
    }

    var validation = markers.filter(marker => marker.type === 'validation');
    var errors = validation.filter(marker => marker.level === 'error');
    var classname = (0, _classnames.default)([_InlineObject.default.root, editor.value.selection.focus.isInNode(node) && _InlineObject.default.focused, isSelected && _InlineObject.default.selected, errors.length > 0 && _InlineObject.default.hasErrors]);
    var valueKeys = value ? Object.keys(value) : [];
    var isEmpty = !value || (0, _isEqual2.default)(valueKeys.sort(), ['_key', '_type'].sort());
    return _react.default.createElement("span", _extends({}, attributes, {
      onDragStart: this.handleDragStart,
      onDragEnd: this.handleDragEnd,
      onDragEnter: this.handleCancelEvent,
      onDragLeave: this.handleCancelEvent,
      onDrop: this.handleCancelEvent,
      draggable: !readOnly,
      className: classname,
      contentEditable: false
    }), _react.default.createElement("span", {
      onClick: readOnly ? this.handleView : this.handleEditStart,
      ref: this.refPreviewContainer,
      className: _InlineObject.default.previewContainer,
      style: readOnly ? {
        cursor: 'default'
      } : {}
    }, !isEmpty && _react.default.createElement(_Preview.default, {
      type: type,
      value: value,
      layout: "inline"
    }), isEmpty && !readOnly && _react.default.createElement("span", null, "Click to edit")));
  }

}

exports.default = InlineObject;

_defineProperty(InlineObject, "defaultProps", {
  isSelected: false,
  readOnly: false
});