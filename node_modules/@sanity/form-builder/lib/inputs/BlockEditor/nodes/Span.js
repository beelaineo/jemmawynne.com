"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireDefault(require("react"));

var _paths = require("@sanity/util/paths");

var _slate = require("slate");

var _InvalidValueInput = _interopRequireDefault(require("../../InvalidValueInput"));

var _Span = _interopRequireDefault(require("./styles/Span.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class Span extends _react.default.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "_clickCounter", 0);

    _defineProperty(this, "_isMarkingText", false);

    _defineProperty(this, "handleMouseDown", () => {
      var readOnly = this.props.readOnly;
      this._isMarkingText = true;
      setTimeout(() => {
        if (this._clickCounter === 1 && !this._isMarkingText) {
          if (readOnly) {
            this.handleView();
          } else {
            this.startEditing();
          }
        }

        this._clickCounter = 0;
      }, 200);
      this._clickCounter++;
    });

    _defineProperty(this, "handleInvalidValue", event => {
      var _event = event;
      var _this$props = this.props,
          editor = _this$props.editor,
          onPatch = _this$props.onPatch;

      var key = this.getFirstAnnotation()._key;

      var parentBlock = editor.value.document.getClosestBlock(this.props.node.key);
      var path = [{
        _key: parentBlock.key
      }, 'markDefs', {
        _key: key
      }];
      path.reverse().forEach(part => {
        _event = _event.prefixAll(part);
      });
      onPatch(_event, this.getFirstAnnotation());
    });

    _defineProperty(this, "handleView", () => {
      var _this$props2 = this.props,
          editor = _this$props2.editor,
          node = _this$props2.node,
          onFocus = _this$props2.onFocus;
      onFocus([{
        _key: editor.value.document.getParent(node.key).key
      }, 'markDefs', {
        _key: node.data.get('annotations')[this.state.focusedAnnotationName]._key
      }, _paths.FOCUS_TERMINATOR]);
    });

    _defineProperty(this, "handleMouseUp", () => {
      this._isMarkingText = false;
    });

    _defineProperty(this, "handleInvalidTypeContainerClick", event => {
      event.preventDefault();
      event.stopPropagation();
    });

    _defineProperty(this, "handleClick", () => {
      var type = this.props.type;

      if (!type) {
        return;
      } // Don't do anyting if this type doesn't support any annotations.


      if (!type.annotations || type.annotations.length === 0) {
        return;
      }

      var annotations = this.getAnnotations(); // Try to figure out which annotation that should be focused when user clicks the span

      var focusedAnnotationName;

      if (type.annotations && type.annotations.length === 1) {
        // Only one annotation type, always focus this one
        focusedAnnotationName = type.annotations[0].name;
      } else if (annotations && Object.keys(annotations).length === 1) {
        // Only one annotation value, focus it
        focusedAnnotationName = annotations[Object.keys(annotations)[0]]._type;
      }

      if (focusedAnnotationName) {
        this.focusAnnotation(focusedAnnotationName);
      } // If no focusedAnnotationName was found, buttons to edit respective annotations will be show

    });

    var _focusedAnnotationName = this.props.node.data.get('focusedAnnotationName');

    this.state = {
      focusedAnnotationName: _focusedAnnotationName
    };
  }

  getAnnotations() {
    return this.props.node.data.get('annotations');
  }

  focusAnnotation(annotationName) {
    var _this$props3 = this.props,
        node = _this$props3.node,
        editor = _this$props3.editor;
    this.setState({
      focusedAnnotationName: annotationName
    });

    if (node.data.get('focusedAnnotationName') === annotationName) {
      return;
    }

    var data = _objectSpread({}, node.data.toObject(), {
      focusedAnnotationName: annotationName
    });

    editor.setNodeByKey(node.key, {
      data
    });
  } // Open dialog when user clicks the node,
  // but don't act on double clicks (mark text as normal)


  startEditing() {
    var _this$props4 = this.props,
        editor = _this$props4.editor,
        node = _this$props4.node,
        onFocus = _this$props4.onFocus;
    var block = editor.value.document.getClosestBlock(node.key);
    var focusPath = [{
      _key: block.key
    }, 'markDefs', {
      _key: node.data.get('annotations')[this.state.focusedAnnotationName]._key
    }, _paths.FOCUS_TERMINATOR];
    editor.blur();
    setTimeout(() => {
      onFocus(focusPath);
    }, 100);
  }

  getFirstAnnotation() {
    var annotations = this.getAnnotations();
    return annotations[Object.keys(annotations)[0]];
  }

  render() {
    var _this$props5 = this.props,
        attributes = _this$props5.attributes,
        blockContentFeatures = _this$props5.blockContentFeatures,
        markers = _this$props5.markers;
    var children = this.props.children;
    var annotations = this.getAnnotations();
    var annotationTypes = blockContentFeatures.annotations.filter(item => Object.keys(annotations).includes(item.value));
    annotationTypes.forEach(annotation => {
      var CustomComponent = annotation && annotation.blockEditor && annotation.blockEditor.render ? annotation.blockEditor.render : null;

      if (CustomComponent) {
        children = _react.default.createElement(CustomComponent, annotations[annotation.value], children);
      }
    });

    if (annotationTypes.length === 0) {
      var firstAnnotation = this.getFirstAnnotation();
      return _react.default.createElement("span", _extends({}, attributes, {
        className: _Span.default.error,
        onClick: this.handleInvalidTypeContainerClick,
        contentEditable: false
      }), children, _react.default.createElement(_InvalidValueInput.default, {
        validTypes: blockContentFeatures.annotations.map(a => a.type.name),
        actualType: firstAnnotation._type,
        value: firstAnnotation,
        onChange: this.handleInvalidValue
      }));
    }

    var validation = markers.filter(marker => marker.type === 'validation');
    var errors = validation.filter(marker => marker.level === 'error');
    return _react.default.createElement("span", _extends({}, attributes, {
      onMouseDown: this.handleMouseDown,
      onMouseUp: this.handleMouseUp,
      onClick: this.handleClick,
      className: errors.length ? _Span.default.error : _Span.default.valid
    }), children);
  }

}

exports.default = Span;

_defineProperty(Span, "defaultProps", {
  readOnly: false
});