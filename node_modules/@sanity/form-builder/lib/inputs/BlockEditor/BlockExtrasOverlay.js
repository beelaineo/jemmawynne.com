"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _slateReact = require("slate-react");

var _blockExtras = _interopRequireDefault(require("part:@sanity/form-builder/input/block-editor/block-extras"));

var _PatchEvent = _interopRequireDefault(require("../../../PatchEvent"));

var _createBlockActionPatchFn = _interopRequireDefault(require("./utils/createBlockActionPatchFn"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class BlockExtrasOverlay extends _react.default.Component {
  constructor() {
    super(...arguments);

    _defineProperty(this, "state", {
      windowWidth: undefined,
      // eslint-disable-line react/no-unused-state
      visible: false
    });

    _defineProperty(this, "handleResize", () => {
      this.setState({
        windowWidth: window.innerWidth // eslint-disable-line react/no-unused-state

      });
    });

    _defineProperty(this, "renderBlockExtras", node => {
      var _this$props = this.props,
          onFocus = _this$props.onFocus,
          renderCustomMarkers = _this$props.renderCustomMarkers,
          renderBlockActions = _this$props.renderBlockActions,
          onPatch = _this$props.onPatch,
          fullscreen = _this$props.fullscreen,
          editor = _this$props.editor;
      var markers = this.props.markers.filter(marker => marker.path[0] && marker.path[0]._key && marker.path[0]._key === node.key);

      if (markers.length === 0 && !renderBlockActions) {
        return null;
      }

      var element;

      try {
        element = (0, _slateReact.findDOMNode)(node); // eslint-disable-line react/no-find-dom-node
      } catch (err) {
        return null;
      }

      var rect = element.getBoundingClientRect();
      var actions = null;
      var value = this.props.value || [];

      if (renderBlockActions) {
        var block = value.find(blk => blk._key == node.key);
        var RenderComponent = renderBlockActions;

        if (block) {
          actions = _react.default.createElement(RenderComponent, {
            element: element,
            block: block,
            value: value,
            path: [{
              _key: block._key
            }],
            set: (0, _createBlockActionPatchFn.default)('set', block, onPatch),
            unset: (0, _createBlockActionPatchFn.default)('unset', block, onPatch),
            insert: (0, _createBlockActionPatchFn.default)('insert', block, onPatch)
          });
        }
      }

      if (markers.length === 0 && !actions) {
        return null;
      }

      return _react.default.createElement("div", {
        key: node.key,
        style: {
          position: 'absolute',
          top: element.scrollTop + element.offsetTop,
          width: '100%',
          height: rect.height,
          left: 0
        }
      }, _react.default.createElement(_blockExtras.default, {
        block: node,
        fullscreen: fullscreen,
        blockActions: actions,
        editor: editor && editor.current,
        markers: markers,
        onFocus: onFocus,
        renderCustomMarkers: renderCustomMarkers
      }));
    });
  }

  componentDidMount() {
    window.addEventListener('resize', this.handleResize); // Wait for things to get finshed rendered before rendering the aboslute positions

    this._setVisibleTimer = setTimeout(() => window.requestAnimationFrame(() => {
      this.setState({
        visible: true
      });
      this._setVisibleTimer = setTimeout(() => {
        this.setState({
          visible: true
        });
      }, 200);
    }), 0);
  }

  componentWillUnmount() {
    window.removeEventListener('resize', this.handleResize);
    clearTimeout(this._setVisibleTimer);
  } // Don't update this while user is writing


  shouldComponentUpdate(nextProps) {
    if (nextProps.userIsWritingText === true) {
      return false;
    }

    return true;
  }

  render() {
    var visible = this.state.visible;

    if (!visible) {
      return null;
    }

    var editorValue = this.props.editorValue;

    if (!editorValue) {
      return null;
    }

    return _react.default.createElement(_react.Fragment, null, editorValue.document.nodes.map(this.renderBlockExtras));
  }

}

exports.default = BlockExtrasOverlay;