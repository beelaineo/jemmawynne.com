"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = PastePlugin;

var _blockTools = _interopRequireDefault(require("@sanity/block-tools"));

var _slate = require("slate");

var _slateReact = require("slate-react");

var _deserialize = _interopRequireDefault(require("../utils/deserialize"));

var _buildEditorSchema = _interopRequireDefault(require("../utils/buildEditorSchema"));

var _createEditorController = _interopRequireDefault(require("../utils/createEditorController"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function processNode(node, editor) {
  if (!node.get('nodes')) {
    return node;
  }

  var newKey = _blockTools.default.randomKey(12);

  var SlateType = node.constructor;
  var newData = node.get('data') ? node.get('data').toObject() : {};
  newData._key = newKey;

  if (newData.value && newData.value._key) {
    newData.value._key = newKey;
  }

  if (newData.annotations) {
    Object.keys(newData.annotations).forEach(key => {
      newData.annotations[key]._key = _blockTools.default.randomKey(12);
    });
  }

  return new SlateType({
    data: _slate.Data.create(newData),
    isVoid: editor.query('isVoid', node),
    key: newKey,
    nodes: node.get('nodes').map(childNode => processNode(childNode, editor)),
    type: node.get('type')
  });
}

var NOOP = () => {};

var wait = ms => new Promise(resolve => setTimeout(resolve, ms));

function handleHTML(html, editor, blockContentType, onProgress, pasteController) {
  return wait(100).then(() => {
    onProgress({
      status: 'html'
    });

    var blocks = _blockTools.default.htmlToBlocks(html, blockContentType);

    onProgress({
      status: 'blocks'
    });
    var value = (0, _deserialize.default)(blocks, blockContentType);
    pasteController.setValue(value); // If we have a placeholder block, we cant do insertFragment,
    // because that may create a new placeholder block,
    // because insertFragment may empty the document while operating

    var placeHolderBlock = editor.value.document.nodes.find(blk => blk.get('data').toObject().placeholder === true);

    if (placeHolderBlock) {
      pasteController.value.document.nodes.forEach(blk => {
        editor.insertBlock(blk);
      });
      editor.removeNodeByKey(placeHolderBlock.key);
    } else {
      editor.insertFragment(pasteController.value.document);
    }

    pasteController.setValue((0, _deserialize.default)(null, blockContentType));
    onProgress({
      status: null
    });
    return editor;
  });
}

function PastePlugin() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var blockContentType = options.blockContentType;
  var onProgress = options.onProgress || NOOP;

  if (!blockContentType) {
    throw new Error("Missing required option 'blockContentType'");
  }

  var editorSchema = (0, _buildEditorSchema.default)(options.blockContentFeatures);
  var controllerOpts = {
    plugins: [{
      schema: editorSchema
    }]
  };
  var pasteController = (0, _createEditorController.default)(controllerOpts);

  function onPaste(event, editor, next) {
    event.preventDefault();
    onProgress({
      status: 'start'
    });
    var transfer = (0, _slateReact.getEventTransfer)(event);
    var fragment = transfer.fragment,
        html = transfer.html,
        text = transfer.text;
    var type = transfer.type;

    if (type === 'fragment') {
      onProgress({
        status: 'fragment'
      }); // Check if we have all block types in the schema,
      // otherwise, use html version

      var allSchemaBlockTypes = blockContentType.of.map(ofType => ofType.name).concat('contentBlock');
      var allBlocksHasSchemaDef = fragment.nodes.map(node => node.type).every(nodeType => allSchemaBlockTypes.includes(nodeType));

      if (allBlocksHasSchemaDef) {
        var focusBlock = editor.value.focusBlock;

        var newNodesList = _slate.Block.createList(fragment.nodes.map(node => processNode(node, editor)));

        var newDoc = new _slate.Document({
          key: fragment.key,
          nodes: newNodesList
        });
        newDoc.nodes.forEach((block, index) => {
          if (index === 0 && focusBlock && !editor.query('isVoid', focusBlock) && focusBlock.nodes.size === 1 && focusBlock.text === '') {
            editor.insertBlock(block).moveToEndOfBlock().removeNodeByKey(focusBlock.key);
          } else {
            editor.insertBlock(block).moveToEndOfBlock();
          }
        });
        onProgress({
          status: null
        });
        return editor;
      }
    }

    onProgress({
      status: 'parsing'
    });

    if (!text && !html) {
      onProgress({
        status: null
      });
      return true;
    }

    handleHTML(html || "<html><body>".concat(text.split('\n').map(line => "<p>".concat(line, "</p>")), "</body></html>"), editor, blockContentType, onProgress, pasteController).catch(err => {
      onProgress({
        status: null,
        error: err
      });
      throw err;
    });
    return true;
  }

  return {
    onPaste
  };
}