"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createOperationToPatches;
exports.VALUE_TO_JSON_OPTS = void 0;

var _isEqual2 = _interopRequireDefault(require("lodash/isEqual"));

var _get2 = _interopRequireDefault(require("lodash/get"));

var _blockTools = require("@sanity/block-tools");

var _slate = require("slate");

var _PatchEvent = require("../../../PatchEvent");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var VALUE_TO_JSON_OPTS = {
  preserveData: true,
  preserveKeys: true,
  preserveSelection: false,
  preserveHistory: false
};
exports.VALUE_TO_JSON_OPTS = VALUE_TO_JSON_OPTS;

function findSpanTargetPath(nodeInEditorValue, offset, editorValue, block) {
  if (nodeInEditorValue.object !== 'text') {
    throw new Error('Not a text node!');
  }

  var nodeInEditorValueParent = editorValue.document.getParent(nodeInEditorValue.key);
  var count = 0;
  var targetKey; // Note: do 'some' here so we can short circuit it when we reach our target
  // and don't have to loop through everything

  nodeInEditorValueParent.nodes.some(node => {
    if (node.object === 'text') {
      var text = '';
      node.leaves.forEach(leaf => {
        text += leaf.text;

        if (node === nodeInEditorValue && text.length > offset) {
          targetKey = "".concat(block._key).concat(count);
          return;
        }

        count++;
      });
    } else {
      count++;
    }

    return node === nodeInEditorValue;
  });

  if (targetKey) {
    return [{
      _key: block._key
    }, 'children', {
      _key: targetKey
    }, 'text'];
  }

  throw new Error("No target path found!");
}

function createOperationToPatches(blockContentFeatures, blockContentType) {
  function toBlock(editorValue, index) {
    if (!editorValue.document.nodes.get(index)) {
      throw new Error("No block found at index ".concat(index, " in value"));
    }

    return (0, _blockTools.editorValueToBlocks)({
      document: {
        nodes: [editorValue.document.nodes.get(index).toJSON(VALUE_TO_JSON_OPTS)]
      }
    }, blockContentType)[0];
  } // eslint-disable-next-line complexity


  function insertTextPatch(operation, beforeValue, afterValue, formBuilderValue) {
    // Make sure we have a document / start block first
    if (!formBuilderValue || formBuilderValue.length === 0) {
      var blocks = (0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType); // Value is undefined

      if (!formBuilderValue) {
        return [(0, _PatchEvent.setIfMissing)(blocks), (0, _PatchEvent.set)(blocks, [])];
      } // Value is empty


      if (formBuilderValue && formBuilderValue.length === 0) {
        return [(0, _PatchEvent.set)(blocks, [])];
      }
    }

    var blockBefore = toBlock(beforeValue, operation.path.get(0));
    var blockAfter = toBlock(afterValue, operation.path.get(0));
    var nodeInEditorValue = afterValue.document.getNode(operation.path);
    var targetPath = findSpanTargetPath(nodeInEditorValue, operation.offset, afterValue, blockAfter);
    var targetKey = (0, _get2.default)(targetPath.slice(-2)[0], '_key');
    var span = blockAfter.children.find(child => child._key === targetKey);

    if (!span) {
      throw new Error("Could not find span with key '".concat(targetKey, "' in block"));
    }

    var nodeInEditorValueBefore = beforeValue.document.getNode(operation.path); // If leaves have changed, and we are not on the end of the text,
    // set the whole block so we get the new block structure right

    if (nodeInEditorValue.leaves.size !== beforeValue.document.getNode(operation.path).leaves.size && operation.offset !== nodeInEditorValueBefore.text.length) {
      return setNodePatch(operation, beforeValue, afterValue, formBuilderValue);
    } // The span doesn't exist from before, so do an insert patch


    if (blockBefore.children.some(child => child._key === targetKey) === false) {
      var spanIndex = blockAfter.children.findIndex(child => child._key === targetKey);
      var targetInsertPath = targetPath.slice(0, -2).concat({
        _key: blockAfter.children[spanIndex - 1]._key
      });
      return [(0, _PatchEvent.insert)([span], 'after', targetInsertPath)];
    } // Check if marks have changed and set the whole span with new marks if so


    var point = {
      path: operation.path,
      offset: operation.offset + 1
    };
    var textMarks = beforeValue.document.getMarksAtRange(_slate.Range.fromJSON({
      anchor: point,
      focus: point
    })).map(m => m.type).toArray();

    if (!(0, _isEqual2.default)(textMarks, span.marks)) {
      return [(0, _PatchEvent.set)(span, targetPath.slice(0, -1))];
    } // Marks not changed, just set the text


    return [(0, _PatchEvent.set)(span.text, targetPath)];
  }

  function setNodePatch(operation, beforeValue, afterValue, formBuilderValue) {
    if (afterValue.document.nodes.size > 0 && afterValue.document.nodes.every(node => node.data.get('placeholder'))) {
      return [(0, _PatchEvent.unset)([])];
    } // Value is undefined


    if (!formBuilderValue) {
      var blocks = (0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType);
      return [(0, _PatchEvent.setIfMissing)(blocks), (0, _PatchEvent.set)(blocks)];
    } // Value is empty


    if (formBuilderValue && formBuilderValue.length === 0) {
      return [(0, _PatchEvent.set)((0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType), [])];
    }

    var block = toBlock(afterValue, operation.path.get(0));
    return [(0, _PatchEvent.set)(block, [{
      _key: block._key
    }])];
  }

  function insertNodePatch(operation, beforeValue, afterValue, formBuilderValue) {
    // Don't send anything if this is just a placeholder
    if (afterValue.document.nodes.size > 0 && afterValue.document.nodes.every(node => node.data.get('placeholder'))) {
      return [];
    } // Value is undefined


    if (!formBuilderValue) {
      var blocks = (0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType);
      return [(0, _PatchEvent.setIfMissing)(blocks), (0, _PatchEvent.set)(blocks, [])];
    } // Value is empty


    if (formBuilderValue && formBuilderValue.length === 0) {
      return [(0, _PatchEvent.set)((0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType), [])];
    }

    var block = toBlock(afterValue, operation.path.get(0));

    if (operation.path.size === 1) {
      var position = 'after';
      var positionPath;

      if (operation.path.get(0) === 0) {
        var firstNode = beforeValue.document.nodes.first();
        positionPath = firstNode ? [{
          _key: firstNode.key
        }] : [0];
        position = 'before';
      } else {
        positionPath = [{
          _key: beforeValue.document.nodes.get(operation.path.get(0) - 1).key
        }];
      }

      return [(0, _PatchEvent.insert)([block], position, positionPath)];
    }

    return [(0, _PatchEvent.set)(block, [{
      _key: block._key
    }])];
  }

  function splitNodePatch(operation, afterValue, formBuilderValue) {
    // Value is undefined
    if (!formBuilderValue) {
      var blocks = (0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType);
      return [(0, _PatchEvent.setIfMissing)(blocks), (0, _PatchEvent.set)(blocks)];
    } // Value is empty


    if (formBuilderValue && formBuilderValue.length === 0) {
      return [(0, _PatchEvent.set)((0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType), [])];
    }

    var patches = [];
    var splitBlock = toBlock(afterValue, operation.path.get(0));

    if (operation.path.size === 1) {
      patches.push((0, _PatchEvent.set)(splitBlock, [{
        _key: splitBlock._key
      }]));
      var newBlock = toBlock(afterValue, operation.path.get(0) + 1);
      patches.push((0, _PatchEvent.insert)([newBlock], 'after', [{
        _key: splitBlock._key
      }]));
    }

    if (operation.path.size > 1) {
      patches.push((0, _PatchEvent.set)(splitBlock, [{
        _key: splitBlock._key
      }]));
    }

    return patches;
  }

  function mergeNodePatch(operation, afterValue, formBuilderValue) {
    var patches = []; // Value is undefined

    if (!formBuilderValue) {
      var blocks = (0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType);
      return [(0, _PatchEvent.setIfMissing)(blocks), (0, _PatchEvent.set)(blocks)];
    } // Value is empty


    if (formBuilderValue && formBuilderValue.length === 0) {
      return [(0, _PatchEvent.set)((0, _blockTools.editorValueToBlocks)(afterValue.toJSON(VALUE_TO_JSON_OPTS), blockContentType), [])];
    }

    if (operation.path.size === 1) {
      var mergedBlock = toBlock(afterValue, operation.path.get(0));
      var targetBlock = toBlock(afterValue, operation.path.get(0) - 1);
      patches.push((0, _PatchEvent.unset)([{
        _key: mergedBlock._key
      }]));
      patches.push((0, _PatchEvent.set)(targetBlock, [{
        _key: targetBlock._key
      }]));
    }

    if (operation.path.size > 1) {
      var _mergedBlock = toBlock(afterValue, operation.path.get(0));

      patches.push((0, _PatchEvent.set)(_mergedBlock, [{
        _key: _mergedBlock._key
      }]));
    }

    return patches;
  }

  function moveNodePatch(operation, beforeValue, afterValue) {
    var patches = [];

    if (operation.path.size === 1) {
      if (operation.path.get(0) === operation.newPath.get(0)) {
        return [];
      }

      var block = toBlock(beforeValue, operation.path.get(0));
      patches.push((0, _PatchEvent.unset)([{
        _key: block._key
      }]));
      var position = 'after';
      var positionPath;

      if (operation.path.get(0) === 0) {
        var firstNode = beforeValue.document.nodes.first();
        positionPath = firstNode ? [{
          _key: firstNode.key
        }] : [0];
        position = 'before';
      } else {
        positionPath = [{
          _key: beforeValue.document.nodes.get(operation.path.get(0) - 1).key
        }];
      }

      patches.push((0, _PatchEvent.insert)(block, position, positionPath));
    } else {
      var changedBlockFrom = toBlock(afterValue, operation.path.get(0));
      var changedBlockTo = toBlock(afterValue, operation.newPath.get(0));
      patches.push((0, _PatchEvent.set)(changedBlockFrom, [{
        _key: changedBlockFrom._key
      }]));
      patches.push((0, _PatchEvent.set)(changedBlockTo, [{
        _key: changedBlockTo._key
      }]));
    }

    return patches;
  }

  function removeNodePatch(operation, beforeValue, afterValue) {
    var patches = [];
    var block = toBlock(beforeValue, operation.path.get(0));

    if (operation.path.size === 1) {
      patches.push((0, _PatchEvent.unset)([{
        _key: block._key
      }]));
    }

    if (operation.path.size > 1) {
      // Only relevant for 'block' type blocks
      if (block._type !== 'block') {
        return patches;
      }

      var changedBlock = toBlock(afterValue, operation.path.get(0));
      patches.push((0, _PatchEvent.set)(changedBlock, [{
        _key: changedBlock._key
      }]));
    }

    if (patches.length === 0) {
      throw new Error("Don't know how to unset ".concat(JSON.stringify(operation.toJSON(VALUE_TO_JSON_OPTS))));
    }

    return patches;
  } // eslint-disable-next-line complexity


  return function operationToPatches(operation, beforeValue, afterValue, formBuilderValue // This is optional, but needed for setting setIfMissing patches correctly
  ) {
    // console.log(JSON.stringify(operation.toJSON(), null, 2))
    switch (operation.type) {
      case 'insert_text':
        return insertTextPatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'remove_text':
        return setNodePatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'add_mark':
        return setNodePatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'remove_mark':
        return setNodePatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'set_node':
        return setNodePatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'insert_node':
        return insertNodePatch(operation, beforeValue, afterValue, formBuilderValue);

      case 'remove_node':
        return removeNodePatch(operation, beforeValue, afterValue);

      case 'split_node':
        return splitNodePatch(operation, afterValue, formBuilderValue);

      case 'merge_node':
        return mergeNodePatch(operation, beforeValue, formBuilderValue);

      case 'move_node':
        return moveNodePatch(operation, beforeValue, afterValue);

      default:
        return [];
    }
  };
}