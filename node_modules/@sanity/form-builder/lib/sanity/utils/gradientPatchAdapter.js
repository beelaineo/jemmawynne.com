"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.toGradient = toGradient;
exports.toFormBuilder = toFormBuilder;

var _flatten2 = _interopRequireDefault(require("lodash/flatten"));

var _mutator = require("@sanity/mutator");

var _assert = _interopRequireDefault(require("assert"));

var convertPath = _interopRequireWildcard(require("./convertPath"));

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function toGradient(patches) {
  return patches.map(toGradientPatch);
}

function toFormBuilder(origin, patches) {
  return (0, _flatten2.default)(patches.map(patch => toFormBuilderPatch(origin, patch)));
}

var notIn = values => value => !values.includes(value);

function toFormBuilderPatch(origin, patch) {
  return (0, _flatten2.default)(Object.keys(patch).filter(notIn(['id', 'ifRevisionID', 'query'])).map(type => {
    if (type === 'unset') {
      return patch.unset.map(path => {
        return {
          type: 'unset',
          path: convertPath.toFormBuilder(path),
          origin
        };
      });
    }

    if (type === 'insert') {
      var position = 'before' in patch.insert ? 'before' : 'after';
      return {
        type: 'insert',
        position: position,
        path: convertPath.toFormBuilder(patch.insert[position]),
        items: patch.insert.items,
        origin
      };
    }

    return Object.keys(patch[type]).map(gradientPath => {
      if (type === 'set') {
        return {
          type: 'set',
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }

      if (type === 'inc' || type === 'dec') {
        return {
          type: type,
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }

      if (type === 'setIfMissing') {
        return {
          type: 'setIfMissing',
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }

      if (type === 'diffMatchPatch') {
        return {
          type: 'diffMatchPatch',
          path: convertPath.toFormBuilder(gradientPath),
          value: patch[type][gradientPath],
          origin
        };
      }

      console.warn(new Error("Unsupported patch type: ".concat(type)));
      return null;
    }).filter(Boolean);
  }));
}

function toGradientPatch(patch) {
  var matchPath = (0, _mutator.arrayToJSONMatchPath)(patch.path || []);

  if (patch.type === 'insert') {
    var position = patch.position,
        items = patch.items;
    return {
      insert: {
        [position]: matchPath,
        items: items
      }
    };
  }

  if (patch.type === 'unset') {
    return {
      unset: [matchPath]
    };
  }

  (0, _assert.default)(patch.type, "Missing patch type in patch ".concat(JSON.stringify(patch)));

  if (matchPath) {
    return {
      [patch.type]: {
        [matchPath]: patch.value
      }
    };
  }

  return {
    [patch.type]: patch.value
  };
}