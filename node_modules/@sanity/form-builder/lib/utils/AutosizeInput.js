"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _react = _interopRequireWildcard(require("react"));

var _propTypes = _interopRequireDefault(require("prop-types"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

function _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

var sizerStyle = {
  position: 'absolute',
  top: 0,
  left: 0,
  visibility: 'hidden',
  height: 0,
  overflow: 'scroll',
  whiteSpace: 'pre'
};

class AutosizeInput extends _react.Component {
  constructor(props) {
    super(props);

    _defineProperty(this, "inputRef", el => {
      this.input = el;

      if (typeof this.props.inputRef === 'function') {
        this.props.inputRef(el);
      }
    });

    _defineProperty(this, "placeHolderSizerRef", el => {
      this.placeHolderSizer = el;
    });

    _defineProperty(this, "sizerRef", el => {
      this.sizer = el;
    });

    this.state = {
      inputWidth: props.minWidth,
      inputId: "_".concat(Math.random().toString(36).substr(2, 12))
    };
  }

  componentDidMount() {
    this.mounted = true;
    this.copyInputStyles();
    this.updateInputWidth();
  }

  componentDidUpdate(prevProps, prevState) {
    if (prevState.inputWidth !== this.state.inputWidth) {
      if (typeof this.props.onAutosize === 'function') {
        this.props.onAutosize(this.state.inputWidth);
      }
    }

    this.updateInputWidth();
  }

  componentWillUnmount() {
    this.mounted = false;
  }

  copyInputStyles() {
    if (!this.mounted || !window.getComputedStyle) {
      return;
    }

    var inputStyle = this.input && window.getComputedStyle(this.input);

    if (!inputStyle) {
      return;
    }

    var widthNode = this.sizer;
    widthNode.style.fontSize = inputStyle.fontSize;
    widthNode.style.fontFamily = inputStyle.fontFamily;
    widthNode.style.fontWeight = inputStyle.fontWeight;
    widthNode.style.fontStyle = inputStyle.fontStyle;
    widthNode.style.letterSpacing = inputStyle.letterSpacing;
    widthNode.style.textTransform = inputStyle.textTransform;

    if (this.props.placeholder) {
      var placeholderNode = this.placeHolderSizer;
      placeholderNode.style.fontSize = inputStyle.fontSize;
      placeholderNode.style.fontFamily = inputStyle.fontFamily;
      placeholderNode.style.fontWeight = inputStyle.fontWeight;
      placeholderNode.style.fontStyle = inputStyle.fontStyle;
      placeholderNode.style.letterSpacing = inputStyle.letterSpacing;
      placeholderNode.style.textTransform = inputStyle.textTransform;
    }
  }

  updateInputWidth() {
    if (!this.mounted || !this.sizer || typeof this.sizer.scrollWidth === 'undefined') {
      return;
    }

    var newInputWidth;

    if (this.props.placeholder && (!this.props.value || this.props.value && this.props.placeholderIsMinWidth)) {
      newInputWidth = Math.max(this.sizer.scrollWidth, this.placeHolderSizer.scrollWidth) + 2;
    } else {
      newInputWidth = this.sizer.scrollWidth + 2;
    }

    if (newInputWidth < this.props.minWidth) {
      newInputWidth = this.props.minWidth;
    }

    if (newInputWidth !== this.state.inputWidth) {
      this.setState({
        inputWidth: newInputWidth
      });
    }
  }

  getInput() {
    return this.input;
  }

  focus() {
    this.input.focus();
  }

  blur() {
    this.input.blur();
  }

  select() {
    this.input.select();
  }

  render() {
    var sizerValue = [this.props.defaultValue, this.props.value, ''].reduce((previousValue, currentValue) => {
      if (previousValue !== null && previousValue !== undefined) {
        return previousValue;
      }

      return currentValue;
    });

    var wrapperStyle = _objectSpread({}, this.props.style);

    if (!wrapperStyle.display) {
      wrapperStyle.display = 'inline-block';
    }

    var inputStyle = _objectSpread({}, this.props.inputStyle);

    inputStyle.width = "".concat(this.state.inputWidth, "px");
    inputStyle.boxSizing = 'content-box';

    var inputProps = _extends({}, this.props);

    inputProps.className = this.props.inputClassName;
    inputProps.style = inputStyle; // ensure props meant for `AutosizeInput` don't end up on the `input`

    delete inputProps.inputClassName;
    delete inputProps.inputStyle;
    delete inputProps.minWidth;
    delete inputProps.onAutosize;
    delete inputProps.placeholderIsMinWidth;
    delete inputProps.inputRef;
    return _react.default.createElement("div", {
      className: this.props.className,
      style: wrapperStyle
    }, _react.default.createElement("style", {
      dangerouslySetInnerHTML: {
        __html: ["input#".concat(this.state.id, "::-ms-clear {display: none;}")].join('\n')
      }
    }), _react.default.createElement("input", _extends({
      id: this.state.id
    }, inputProps, {
      ref: this.inputRef
    })), _react.default.createElement("div", {
      ref: this.sizerRef,
      style: sizerStyle
    }, sizerValue), this.props.placeholder ? _react.default.createElement("div", {
      ref: this.placeHolderSizerRef,
      style: sizerStyle
    }, this.props.placeholder) : null);
  }

}

AutosizeInput.propTypes = {
  className: _propTypes.default.string,
  // className for the outer element
  defaultValue: _propTypes.default.any,
  // default field value
  inputClassName: _propTypes.default.string,
  // className for the input element
  inputRef: _propTypes.default.func,
  // ref callback for the input element
  inputStyle: _propTypes.default.object,
  // css styles for the input element
  minWidth: _propTypes.default.oneOfType([// minimum width for input element
  _propTypes.default.number, _propTypes.default.string]),
  onAutosize: _propTypes.default.func,
  // onAutosize handler: function(newWidth) {}
  onChange: _propTypes.default.func,
  // onChange handler: function(newValue) {}
  placeholder: _propTypes.default.string,
  // placeholder text
  placeholderIsMinWidth: _propTypes.default.bool,
  // don't collapse size to less than the placeholder
  style: _propTypes.default.object,
  // css styles for the outer element
  value: _propTypes.default.any // field value

};
AutosizeInput.defaultProps = {
  minWidth: 1
};
var _default = AutosizeInput;
exports.default = _default;