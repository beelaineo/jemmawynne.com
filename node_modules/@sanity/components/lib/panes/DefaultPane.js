"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _negate2 = _interopRequireDefault(require("lodash/negate"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _shallowEquals = _interopRequireDefault(require("shallow-equals"));

var _classnames = _interopRequireDefault(require("classnames"));

var _default2 = _interopRequireDefault(require("part:@sanity/components/menus/default"));

var _moreVertIcon = _interopRequireDefault(require("part:@sanity/base/more-vert-icon"));

var _router = require("part:@sanity/base/router");

var _scrollContainer = _interopRequireDefault(require("part:@sanity/components/utilities/scroll-container"));

var _Styleable = _interopRequireDefault(require("../utilities/Styleable"));

var _DefaultPane = _interopRequireDefault(require("./styles/DefaultPane.css"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function getActionKey(action, index) {
  return (typeof action.action === 'string' ? action.action + action.title : action.title) || index;
} // This is the height of the global navigation bar
// TODO: Turn this into a prop that DefaultPane receives


var GLOBAL_NAV_BAR_HEIGHT = 49;

var getScrollShadowState = (scrollTop, prevState) => {
  var headerStyleRatio = prevState.headerStyleRatio;
  var threshold = 30;

  if (scrollTop < threshold) {
    // Round off the calculation to cut down rerenders that are not visible to the human eye
    // Example: 0.53 -> 0.55 or 0.91 -> 0.9
    var ratio = Math.round(scrollTop / threshold * 20) / 20;

    if (ratio === headerStyleRatio) {
      return null;
    }

    return {
      headerStyleRatio: ratio,
      headerStyle: {
        boxShadow: "0 0 ".concat(2 * ratio, "px rgba(0, 0, 0, ").concat(ratio * 0.2, ")")
      }
    };
  }

  if (scrollTop < 0 && headerStyleRatio !== -1) {
    return {
      headerStyleRatio: -1,
      headerStyle: {
        boxShadow: 'none'
      }
    };
  }

  if (headerStyleRatio !== 1) {
    return {
      headerStyleRatio: 1,
      headerStyle: {
        boxShadow: '0 0px 2px rgba(0, 0, 0, 0.2)'
      }
    };
  }

  return null;
};

var noop = () => {
  /* intentional noop */
};

var isActionButton = item => item.showAsAction;

var isMenuButton = (0, _negate2.default)(isActionButton); // eslint-disable-next-line

class Pane extends _react.default.Component {
  constructor(props) {
    super(props); // Passed to rendered <Menu>. This prevents the "click outside" functionality
    // from kicking in when pressing the toggle menu button

    _defineProperty(this, "state", {
      menuIsOpen: false,
      headerStyleRatio: -1,
      headerStyle: {
        boxShadow: 'none'
      },
      scrollTop: 0
    });

    _defineProperty(this, "scrollFrameId", null);

    _defineProperty(this, "scrollFrame", () => {
      var winScrollTop = (window.pageYOffset || document.scrollTop || 0) - (document.clientTop || 0);
      var scrollTop = Math.max(winScrollTop - GLOBAL_NAV_BAR_HEIGHT, 0);

      if (this.state.scrollTop !== scrollTop) {
        var shadowState = getScrollShadowState(scrollTop, this.state);

        if (shadowState) {
          shadowState.scrollTop = scrollTop;
          this.setState(shadowState);
        } else {
          this.setState({
            scrollTop: scrollTop
          });
        }
      }

      this.scrollFrameId = requestAnimationFrame(this.scrollFrame);
    });

    _defineProperty(this, "handleContentScroll", event => {
      var shadowState = getScrollShadowState(event.target.scrollTop, this.state);

      if (shadowState) {
        this.setState(shadowState);
      }
    });

    _defineProperty(this, "handleCloseMenu", () => {
      this.setState({
        menuIsOpen: false
      });
    });

    _defineProperty(this, "handleMenuToggle", () => {
      this.setState(prev => ({
        menuIsOpen: !prev.menuIsOpen
      }));
    });

    _defineProperty(this, "handleRootClick", event => {
      var _this$props = this.props,
          onExpand = _this$props.onExpand,
          isCollapsed = _this$props.isCollapsed,
          index = _this$props.index;

      if (isCollapsed && onExpand) {
        onExpand(index);
      }
    });

    _defineProperty(this, "handleTitleClick", event => {
      var _this$props2 = this.props,
          onCollapse = _this$props2.onCollapse,
          isCollapsed = _this$props2.isCollapsed,
          index = _this$props2.index;

      if (!isCollapsed && onCollapse) {
        onCollapse(index);
      }
    });

    _defineProperty(this, "handleMenuAction", item => {
      // When closing the menu outright, the menu button will be focused and the "enter" keypress
      // will bouble up to it and trigger a re-open of the menu. To work around this, use rAF to
      // ensure the current event is completed before closing the menu
      this.closeRequest = requestAnimationFrame(() => this.handleCloseMenu());

      if (typeof item.action === 'function') {
        item.action(item.params);
        return;
      }

      this.props.onAction(item);
    });

    _defineProperty(this, "renderIntentAction", (action, i) => {
      var styles = this.props.styles;
      var Icon = action.icon;
      return _react.default.createElement("div", {
        className: styles.buttonWrapper,
        key: getActionKey(action, i)
      }, _react.default.createElement(_router.IntentLink, {
        className: styles.actionButton,
        intent: action.intent.type,
        params: action.intent.params,
        title: action.title
      }, _react.default.createElement("div", {
        className: styles.actionButtonInner,
        tabIndex: -1
      }, _react.default.createElement(Icon, null))));
    });

    _defineProperty(this, "renderAction", (action, i) => {
      if (action.intent) {
        return this.renderIntentAction(action, i);
      }

      var styles = this.props.styles;
      var Icon = action.icon;
      return _react.default.createElement("div", {
        className: styles.buttonWrapper,
        key: getActionKey(action, i)
      }, _react.default.createElement("button", {
        className: styles.actionButton,
        type: "button",
        title: action.title // eslint-disable-next-line react/jsx-no-bind
        ,
        onClick: this.handleMenuAction.bind(this, action)
      }, _react.default.createElement("div", {
        className: styles.actionButtonInner,
        tabIndex: -1
      }, _react.default.createElement(Icon, null))));
    });

    this.paneMenuId = Math.random().toString(36).substr(2, 6);
  }

  static getDerivedStateFromProps(props, state) {
    if (typeof props.scrollTop === 'undefined') {
      return null;
    }

    return getScrollShadowState(props.scrollTop, state);
  }

  componentDidMount() {
    this.scrollFrame();
  }

  componentWillUnmount() {
    if (this.closeRequest) {
      cancelAnimationFrame(this.closeRequest);
    }

    if (this.scrollFrameId) {
      cancelAnimationFrame(this.scrollFrameId);
    }
  }

  shouldComponentUpdate(nextProps, nextState) {
    // The pane header has a styling which gradually adds more shadow and tunes the opacity when
    // scrolling. In the case of "managed" lists (infinite scroll and such), the scroll position
    // is passed as a prop (`scrollTop`). However, passed a certain threshold we no longer need to
    // update, since the styling turns static. To prevent the prop from forcing a re-render,
    // explicitly check for a difference in the state here to short-circuit in this common scenario
    var scrollPropChanged = nextProps.scrollTop !== this.props.scrollTop;
    var headerStyleChanged = nextState.headerStyleRatio !== this.state.headerStyleRatio;

    if (scrollPropChanged && !headerStyleChanged) {
      return false;
    }

    return scrollPropChanged || headerStyleChanged || !(0, _shallowEquals.default)(nextProps, this.props) || !(0, _shallowEquals.default)(nextState, this.state);
  }

  renderMenu() {
    var _this$props3 = this.props,
        styles = _this$props3.styles,
        menuItems = _this$props3.menuItems,
        menuItemGroups = _this$props3.menuItemGroups,
        isCollapsed = _this$props3.isCollapsed;
    var menuIsOpen = this.state.menuIsOpen;
    var items = menuItems.filter(isMenuButton);

    if (items.length === 0) {
      return null;
    }

    return _react.default.createElement("div", {
      className: styles.menuWrapper
    }, _react.default.createElement("button", {
      className: styles.menuOverflowButton // Makes menu component ignore clicks on button (prevents double-toggling)
      ,
      "data-menu-button-id": this.paneMenuId,
      type: "button",
      onClick: this.handleMenuToggle,
      title: "Show menu"
    }, _react.default.createElement("div", {
      className: styles.menuOverflowButtonInner,
      tabIndex: -1
    }, _react.default.createElement(_moreVertIcon.default, null))), _react.default.createElement("div", {
      className: styles.menuContainer
    }, menuIsOpen && _react.default.createElement(_default2.default, {
      id: this.paneMenuId,
      items: items,
      groups: menuItemGroups,
      origin: isCollapsed ? 'top-left' : 'top-right',
      onAction: this.handleMenuAction,
      onClose: this.handleCloseMenu,
      onClickOutside: this.handleCloseMenu
    })));
  }

  render() {
    var _this$props4 = this.props,
        title = _this$props4.title,
        children = _this$props4.children,
        isSelected = _this$props4.isSelected,
        isCollapsed = _this$props4.isCollapsed,
        isScrollable = _this$props4.isScrollable,
        menuItems = _this$props4.menuItems,
        styles = _this$props4.styles,
        renderActions = _this$props4.renderActions,
        staticContent = _this$props4.staticContent,
        contentMaxWidth = _this$props4.contentMaxWidth;
    var headerStyle = isCollapsed ? {} : this.state.headerStyle;
    var actions = menuItems.filter(act => act.showAsAction && (!isCollapsed || act.showAsAction.whenCollapsed));
    return _react.default.createElement("div", {
      className: (0, _classnames.default)([isCollapsed ? styles.isCollapsed : styles.root, isSelected ? styles.isActive : styles.isDisabled]),
      onClick: this.handleRootClick
    }, _react.default.createElement("div", {
      className: styles.header,
      style: {
        boxShadow: headerStyle.boxShadow
      }
    }, _react.default.createElement("div", {
      className: styles.headerContent,
      style: contentMaxWidth ? {
        maxWidth: "".concat(contentMaxWidth, "px")
      } : {}
    }, _react.default.createElement("h2", {
      className: styles.title,
      onClick: this.handleTitleClick
    }, title), _react.default.createElement("div", {
      className: styles.actions
    }, renderActions ? renderActions(actions) : actions.map(this.renderAction), this.renderMenu()))), _react.default.createElement("div", {
      className: styles.main
    }, isScrollable ? _react.default.createElement(_scrollContainer.default, {
      className: styles.scrollContainer,
      onScroll: this.handleContentScroll
    }, _react.default.createElement("div", {
      style: contentMaxWidth ? {
        maxWidth: "".concat(contentMaxWidth, "px")
      } : {}
    }, children)) : _react.default.createElement("div", {
      className: styles.notScrollable
    }, children), staticContent));
  }

}

_defineProperty(Pane, "propTypes", {
  title: _propTypes.default.oneOfType([_propTypes.default.string, _propTypes.default.node]),
  isCollapsed: _propTypes.default.bool,
  onExpand: _propTypes.default.func,
  onCollapse: _propTypes.default.func,
  children: _propTypes.default.node,
  isSelected: _propTypes.default.bool,
  isScrollable: _propTypes.default.bool,
  scrollTop: _propTypes.default.number,
  onAction: _propTypes.default.func,
  renderActions: _propTypes.default.func,
  menuItems: _propTypes.default.arrayOf(_propTypes.default.shape({
    showAsAction: _propTypes.default.oneOfType([_propTypes.default.bool, _propTypes.default.shape({
      whenCollapsed: _propTypes.default.bool
    })])
  })),
  menuItemGroups: _propTypes.default.arrayOf(_propTypes.default.shape({
    id: _propTypes.default.string.isRequired,
    title: _propTypes.default.string
  })),
  index: _propTypes.default.number,
  staticContent: _propTypes.default.node,
  contentMaxWidth: _propTypes.default.number,
  styles: _propTypes.default.object // eslint-disable-line react/forbid-prop-types

});

_defineProperty(Pane, "defaultProps", {
  title: 'Untitled',
  isCollapsed: false,
  isSelected: false,
  scrollTop: undefined,
  isScrollable: true,
  renderActions: undefined,
  styles: {},
  children: _react.default.createElement("div", null),
  onAction: noop,
  menuItems: [],
  menuItemGroups: []
});

var _default = (0, _Styleable.default)(Pane, _DefaultPane.default);

exports.default = _default;