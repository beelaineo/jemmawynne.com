"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _createValidationResult = require("../createValidationResult");

var _inspect = _interopRequireDefault(require("../../inspect"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }

var VALID_FIELD_RE = /^[A-Za-z]+[0-9A-Za-z_]*$/;
var CONVENTIONAL_FIELD_RE = /^[A-Za-z_]+[0-9A-Za-z_]*$/;

function validateFieldName(name) {
  if (typeof name !== 'string') {
    return [(0, _createValidationResult.error)("Field names must be strings. Saw \"".concat((0, _inspect.default)(name), "\""), _createValidationResult.HELP_IDS.OBJECT_FIELD_NAME_INVALID)];
  }

  if (name.startsWith('_')) {
    return [(0, _createValidationResult.error)("Invalid field name \"".concat(name, "\". Field names cannot start with underscores \"_\" as it's reserved for system fields."), _createValidationResult.HELP_IDS.OBJECT_FIELD_NAME_INVALID)];
  }

  if (!VALID_FIELD_RE.test(name)) {
    return [(0, _createValidationResult.error)("Invalid field name: \"".concat(name, "\". Fields can only contain characters from A-Z, numbers and underscores and should not start with a number (must pass the regular expression ").concat(String(VALID_FIELD_RE), ")."), _createValidationResult.HELP_IDS.OBJECT_FIELD_NAME_INVALID)];
  }

  if (!CONVENTIONAL_FIELD_RE.test(name)) {
    return [(0, _createValidationResult.warning)('Thats an interesting field name for sure! But it is... how to put it... a bit... unconventional?' + ' It may be wise to keep special characters out of field names for easier access later on.'), _createValidationResult.HELP_IDS.OBJECT_FIELD_NAME_INVALID];
  }

  return [];
}

function validateField(field, visitorContext) {
  var name = field.name,
      fieldset = field.fieldset,
      fieldType = _objectWithoutProperties(field, ["name", "fieldset"]);

  return 'name' in field ? validateFieldName(name) : [(0, _createValidationResult.error)('Missing field name', _createValidationResult.HELP_IDS.OBJECT_FIELD_NAME_INVALID)];
}

function getDuplicateFields(array) {
  var dupes = {};
  array.forEach(field => {
    if (!dupes[field.name]) {
      dupes[field.name] = [];
    }

    dupes[field.name].push(field);
  });
  return Object.keys(dupes).map(fieldName => dupes[fieldName].length > 1 ? dupes[fieldName] : null).filter(Boolean);
}

var _default = (typeDef, visitorContext) => {
  var problems = [];
  var fieldsIsArray = Array.isArray(typeDef.fields);

  if (fieldsIsArray) {
    var fieldsWithNames = typeDef.fields.filter(field => typeof field.name === 'string');
    getDuplicateFields(fieldsWithNames).forEach(dupes => {
      problems.push((0, _createValidationResult.error)("Found ".concat(dupes.length, " fields with name \"").concat(dupes[0].name, "\" in object"), _createValidationResult.HELP_IDS.OBJECT_FIELD_NOT_UNIQUE));
    });

    if (typeDef.fields.length === 0) {
      problems.push((0, _createValidationResult.error)('Object should have at least one field', _createValidationResult.HELP_IDS.OBJECT_FIELDS_INVALID));
    }
  } else {
    problems.push((0, _createValidationResult.error)("The \"fields\" property must be an array of fields. Instead saw \"".concat(typeof typeDef.fields, "\""), _createValidationResult.HELP_IDS.OBJECT_FIELDS_INVALID));
  }

  return _objectSpread({}, typeDef, {
    fields: (fieldsIsArray ? typeDef.fields : []).map(field => {
      var name = field.name,
          fieldTypeDef = _objectWithoutProperties(field, ["name"]);

      var _visitorContext$visit = visitorContext.visit(fieldTypeDef, visitorContext),
          _problems = _visitorContext$visit._problems,
          fieldType = _objectWithoutProperties(_visitorContext$visit, ["_problems"]);

      return _objectSpread({
        name
      }, fieldType, {
        _problems: validateField(field, visitorContext).concat(_problems || [])
      });
    }),
    _problems: problems
  });
};

exports.default = _default;