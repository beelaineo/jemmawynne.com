'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.TypesHaveDescriptions = TypesHaveDescriptions;

var _buildASTSchema = require('graphql/utilities/buildASTSchema');

var _validation_error = require('../validation_error');

function validateTypeHasDescription(configuration, context, node, typeKind) {
  if ((0, _buildASTSchema.getDescription)(node, {
    commentDescriptions: configuration.getCommentDescriptions()
  })) {
    return;
  }

  var interfaceTypeName = node.name.value;

  context.reportError(new _validation_error.ValidationError('types-have-descriptions', 'The ' + typeKind + ' type `' + interfaceTypeName + '` is missing a description.', [node]));
}

function TypesHaveDescriptions(configuration, context) {
  return {
    TypeExtensionDefinition: function TypeExtensionDefinition(node) {
      return false;
    },
    ScalarTypeDefinition: function ScalarTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'scalar');
    },
    ObjectTypeDefinition: function ObjectTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'object');
    },
    InterfaceTypeDefinition: function InterfaceTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'interface');
    },
    UnionTypeDefinition: function UnionTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'union');
    },
    EnumTypeDefinition: function EnumTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'enum');
    },
    InputObjectTypeDefinition: function InputObjectTypeDefinition(node) {
      validateTypeHasDescription(configuration, context, node, 'input object');
    }
  };
}