'use strict';

var Jest = require("@glennsl/bs-jest/lib/js/src/jest.js");
var $$Array = require("bs-platform/lib/js/array.js");
var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Wonka = require("../src/wonka.js");
var WonkaJs = require("../src/web/wonkaJs.js");
var Caml_array = require("bs-platform/lib/js/caml_array.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Wonka_helpers = require("../src/wonka_helpers.js");
var Wonka_thelpers = require("./wonka_thelpers.js");

describe("source factories", (function () {
        describe("fromList", (function () {
                return Jest.test("sends list items to a puller sink", (function (param) {
                              var source = Wonka.fromList(/* :: */[
                                    10,
                                    /* :: */[
                                      20,
                                      /* :: */[
                                        30,
                                        /* [] */0
                                      ]
                                    ]
                                  ]);
                              var talkback = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var signals = /* array */[];
                              Curry._1(source, (function (signal) {
                                      if (typeof signal === "number" || signal.tag) {
                                        signals.push(signal);
                                        return /* () */0;
                                      } else {
                                        talkback[0] = signal[0];
                                        return /* () */0;
                                      }
                                    }));
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                          /* Push */Block.__(1, [10]),
                                          /* Push */Block.__(1, [20]),
                                          /* Push */Block.__(1, [30]),
                                          /* End */0
                                        ]);
                            }));
              }));
        describe("fromArray", (function () {
                Jest.test("sends array items to a puller sink", (function (param) {
                        var source = Wonka.fromArray(/* array */[
                              10,
                              20,
                              30
                            ]);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* record */[/* contents : array */[]];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals[0] = $$Array.append(signals[0], /* array */[signal]);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals[0] = $$Array.append(signals[0], /* array */[signal]);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals[0]), /* array */[
                                    /* Push */Block.__(1, [10]),
                                    /* Push */Block.__(1, [20]),
                                    /* Push */Block.__(1, [30]),
                                    /* End */0
                                  ]);
                      }));
                return Jest.test("does not blow up the stack when iterating something huge", (function (param) {
                              var arr = Caml_array.caml_make_vect(100000, 123);
                              var source = Wonka.fromArray(arr);
                              var talkback = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var values = /* array */[];
                              Curry._1(source, (function (signal) {
                                      if (typeof signal === "number") {
                                        return /* () */0;
                                      } else if (signal.tag) {
                                        values.push(signal[0]);
                                        return talkback[0](/* Pull */0);
                                      } else {
                                        var x = signal[0];
                                        talkback[0] = x;
                                        return x(/* Pull */0);
                                      }
                                    }));
                              return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](values.length), arr.length);
                            }));
              }));
        describe("fromValue", (function () {
                return Jest.test("sends a single item to a puller sink", (function (param) {
                              var source = Wonka.fromValue(123);
                              var talkback = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var signals = /* array */[];
                              Curry._1(source, (function (signal) {
                                      if (typeof signal === "number" || signal.tag) {
                                        signals.push(signal);
                                        return /* () */0;
                                      } else {
                                        talkback[0] = signal[0];
                                        return /* () */0;
                                      }
                                    }));
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                          /* Push */Block.__(1, [123]),
                                          /* End */0
                                        ]);
                            }));
              }));
        describe("empty", (function () {
                return Jest.test("ends immediately", (function (param) {
                              var talkback = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var signals = /* array */[];
                              Wonka.empty((function (signal) {
                                      if (typeof signal === "number" || signal.tag) {
                                        signals.push(signal);
                                        return /* () */0;
                                      } else {
                                        talkback[0] = signal[0];
                                        return /* () */0;
                                      }
                                    }));
                              var _signals = $$Array.copy(signals);
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](/* tuple */[
                                              _signals,
                                              signals
                                            ]), /* tuple */[
                                          /* array */[/* End */0],
                                          /* array */[/* End */0]
                                        ]);
                            }));
              }));
        describe("never", (function () {
                return Jest.test("does not end", (function (param) {
                              var talkback = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var ended = /* record */[/* contents */false];
                              Wonka.never((function (signal) {
                                      if (typeof signal === "number") {
                                        ended[0] = true;
                                        return /* () */0;
                                      } else if (signal.tag) {
                                        return /* () */0;
                                      } else {
                                        talkback[0] = signal[0];
                                        return /* () */0;
                                      }
                                    }));
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              return Curry._2(Jest.Expect[/* Operators */24][/* == */0], Jest.Expect[/* expect */0](ended[0]), false);
                            }));
              }));
        return /* () */0;
      }));

describe("operator factories", (function () {
        describe("map", (function () {
                Jest.test("maps all emissions of a source", (function (param) {
                        var num = /* record */[/* contents */1];
                        var nums = /* array */[];
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        Curry._1(Wonka.map((function (param) {
                                      var res = num[0];
                                      num[0] = num[0] + 1 | 0;
                                      return res;
                                    }))((function (sink) {
                                    return sink(/* Start */Block.__(0, [(function (signal) {
                                                      if (signal) {
                                                        return /* () */0;
                                                      } else {
                                                        return sink(/* Push */Block.__(1, [1]));
                                                      }
                                                    })]));
                                  })), (function (signal) {
                                if (typeof signal === "number") {
                                  return /* () */0;
                                } else if (signal.tag) {
                                  if (num[0] < 6) {
                                    nums.push(signal[0]);
                                    return talkback[0](/* Pull */0);
                                  } else {
                                    return /* () */0;
                                  }
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    1,
                                    2,
                                    3,
                                    4
                                  ], Jest.Expect[/* expect */0](nums));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.map((function (x) {
                                            return x;
                                          }))).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.map((function (x) {
                                                  return x;
                                                }))).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[/* Close */1],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("filter", (function () {
                Jest.test("filters emissions according to a predicate", (function (param) {
                        var i = /* record */[/* contents */1];
                        var nums = /* array */[];
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        Curry._1(Wonka.filter((function (x) {
                                      return x % 2 === 0;
                                    }))((function (sink) {
                                    return sink(/* Start */Block.__(0, [(function (signal) {
                                                      if (signal) {
                                                        return /* () */0;
                                                      } else {
                                                        var num = i[0];
                                                        i[0] = i[0] + 1 | 0;
                                                        return sink(/* Push */Block.__(1, [num]));
                                                      }
                                                    })]));
                                  })), (function (signal) {
                                if (typeof signal === "number") {
                                  return /* () */0;
                                } else if (signal.tag) {
                                  var x = signal[0];
                                  if (x < 6) {
                                    nums.push(x);
                                    return talkback[0](/* Pull */0);
                                  } else {
                                    return /* () */0;
                                  }
                                } else {
                                  var x$1 = signal[0];
                                  talkback[0] = x$1;
                                  return x$1(/* Pull */0);
                                }
                              }));
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    2,
                                    4
                                  ], Jest.Expect[/* expect */0](nums));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.filter((function (param) {
                                            return true;
                                          }))).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                Jest.testPromise("follows the spec for listenables when filtering", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.filter((function (param) {
                                            return false;
                                          }))).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[
                                                        /* Pull */0,
                                                        /* Pull */0
                                                      ],
                                                      /* array */[/* End */0]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.filter((function (param) {
                                                  return true;
                                                }))).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[/* Close */1],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("scan", (function () {
                Jest.test("folds emissions using an initial seed value", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var source = Wonka.scan((function (acc, x) {
                                  return acc + x | 0;
                                }), 0)((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else {
                                                    var i = num[0];
                                                    if (i <= 3) {
                                                      num[0] = num[0] + 1 | 0;
                                                      return sink(/* Push */Block.__(1, [i]));
                                                    } else {
                                                      return sink(/* End */0);
                                                    }
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [3]),
                                    /* Push */Block.__(1, [6]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.scan((function (param, x) {
                                            return x;
                                          }), 0)).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.scan((function (param, x) {
                                                  return x;
                                                }), 0)).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[/* Close */1],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("merge", (function () {
                Jest.test("merges different sources into a single one", (function (param) {
                        var a = Wonka.fromList(/* :: */[
                              1,
                              /* :: */[
                                2,
                                /* :: */[
                                  3,
                                  /* [] */0
                                ]
                              ]
                            ]);
                        var b = Wonka.fromList(/* :: */[
                              4,
                              /* :: */[
                                5,
                                /* :: */[
                                  6,
                                  /* [] */0
                                ]
                              ]
                            ]);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = Wonka.merge(/* array */[
                              a,
                              b
                            ]);
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [2]),
                                    /* Push */Block.__(1, [3]),
                                    /* Push */Block.__(1, [4]),
                                    /* Push */Block.__(1, [5]),
                                    /* Push */Block.__(1, [6]),
                                    /* End */0
                                  ]);
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable((function (source) {
                                        return Wonka.merge(/* array */[source]);
                                      })).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[
                                                        /* Pull */0,
                                                        /* Pull */0,
                                                        /* Pull */0
                                                      ],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd((function (source) {
                                              return Wonka.merge(/* array */[source]);
                                            })).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[
                                                              /* Pull */0,
                                                              /* Pull */0,
                                                              /* Close */1
                                                            ],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("concat", (function () {
                Jest.test("concatenates different sources into a single one", (function (param) {
                        var a = Wonka.fromList(/* :: */[
                              1,
                              /* :: */[
                                2,
                                /* :: */[
                                  3,
                                  /* [] */0
                                ]
                              ]
                            ]);
                        var b = Wonka.fromList(/* :: */[
                              4,
                              /* :: */[
                                5,
                                /* :: */[
                                  6,
                                  /* [] */0
                                ]
                              ]
                            ]);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = Wonka.concat(/* array */[
                              a,
                              b
                            ]);
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [2]),
                                    /* Push */Block.__(1, [3]),
                                    /* Push */Block.__(1, [4]),
                                    /* Push */Block.__(1, [5]),
                                    /* Push */Block.__(1, [6]),
                                    /* End */0
                                  ]);
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable((function (source) {
                                        return Wonka.concat(/* array */[source]);
                                      })).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[
                                                        /* Pull */0,
                                                        /* Pull */0,
                                                        /* Pull */0
                                                      ],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd((function (source) {
                                              return Wonka.concat(/* array */[source]);
                                            })).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[
                                                              /* Pull */0,
                                                              /* Pull */0,
                                                              /* Close */1
                                                            ],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("share", (function () {
                Jest.test("shares an underlying source with all sinks", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var aborterTb = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var nums = /* array */[];
                        var source = Wonka.share((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else {
                                                    var i = num[0];
                                                    if (i <= 2) {
                                                      num[0] = num[0] + 1 | 0;
                                                      return sink(/* Push */Block.__(1, [i]));
                                                    } else {
                                                      return sink(/* End */0);
                                                    }
                                                  }
                                                })]));
                              }));
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  nums.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  nums.push(signal);
                                  return /* () */0;
                                } else {
                                  return /* () */0;
                                }
                              }));
                        Curry._1(source, (function (signal) {
                                var exit = 0;
                                if (typeof signal === "number" || signal.tag) {
                                  exit = 1;
                                } else {
                                  aborterTb[0] = signal[0];
                                  return /* () */0;
                                }
                                if (exit === 1) {
                                  nums.push(signal);
                                  return aborterTb[0](/* Close */1);
                                }
                                
                              }));
                        talkback[0](/* Pull */0);
                        var numsA = $$Array.copy(nums);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* tuple */[
                                    /* array */[
                                      /* Push */Block.__(1, [1]),
                                      /* Push */Block.__(1, [1]),
                                      /* Push */Block.__(1, [1])
                                    ],
                                    /* array */[
                                      /* Push */Block.__(1, [1]),
                                      /* Push */Block.__(1, [1]),
                                      /* Push */Block.__(1, [1]),
                                      /* Push */Block.__(1, [2]),
                                      /* Push */Block.__(1, [2]),
                                      /* End */0,
                                      /* End */0
                                    ]
                                  ], Jest.Expect[/* expect */0](/* tuple */[
                                        numsA,
                                        nums
                                      ]));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.share).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.share).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[/* Close */1],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("combine", (function () {
                Jest.test("combines the latest values of two sources", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var makeSource = function (factor) {
                          var num = /* record */[/* contents */1];
                          return (function (sink) {
                              return sink(/* Start */Block.__(0, [(function (signal) {
                                                if (signal) {
                                                  return /* () */0;
                                                } else if (num[0] <= 2) {
                                                  var i = Caml_int32.imul(num[0], factor);
                                                  num[0] = num[0] + 1 | 0;
                                                  return sink(/* Push */Block.__(1, [i]));
                                                } else {
                                                  return sink(/* End */0);
                                                }
                                              })]));
                            });
                        };
                        var sourceA = makeSource(1);
                        var sourceB = makeSource(2);
                        var source = Wonka.combine(sourceA)(sourceB);
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [/* tuple */[
                                          1,
                                          2
                                        ]]),
                                    /* Push */Block.__(1, [/* tuple */[
                                          2,
                                          2
                                        ]]),
                                    /* Push */Block.__(1, [/* tuple */[
                                          2,
                                          4
                                        ]]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable((function (source) {
                                        var shared = Wonka.share(source);
                                        return Wonka.combine(shared)(shared);
                                      })).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[],
                                                      /* array */[
                                                        /* Push */Block.__(1, [/* tuple */[
                                                              1,
                                                              1
                                                            ]]),
                                                        /* Push */Block.__(1, [/* tuple */[
                                                              2,
                                                              1
                                                            ]]),
                                                        /* Push */Block.__(1, [/* tuple */[
                                                              2,
                                                              2
                                                            ]]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd((function (source) {
                                              var shared = Wonka.share(source);
                                              return Wonka.combine(shared)(shared);
                                            })).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[/* Close */1],
                                                            /* array */[/* Push */Block.__(1, [/* tuple */[
                                                                    1,
                                                                    1
                                                                  ]])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("take", (function () {
                Jest.test("only lets a maximum number of values through", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var source = Wonka.take(2)((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else {
                                                    var i = num[0];
                                                    num[0] = num[0] + 1 | 0;
                                                    return sink(/* Push */Block.__(1, [i]));
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [2]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.test("accepts the end of the source when max number of emissions is not reached", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var source = Wonka.take(2)((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else {
                                                    var i = num[0];
                                                    if (i < 2) {
                                                      num[0] = num[0] + 1 | 0;
                                                      return sink(/* Push */Block.__(1, [i]));
                                                    } else {
                                                      return sink(/* End */0);
                                                    }
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.take(10)).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                Jest.testPromise("follows the spec for listenables when ending the source", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.take(1)).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[/* Close */1],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.take(10)).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[/* Close */1],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("takeLast", (function () {
                Jest.test("only lets the last n values through on an entirely new source", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var source = Wonka.takeLast(2)((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else if (num[0] <= 4) {
                                                    var i = num[0];
                                                    num[0] = num[0] + 1 | 0;
                                                    return sink(/* Push */Block.__(1, [i]));
                                                  } else {
                                                    return sink(/* End */0);
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [3]),
                                    /* Push */Block.__(1, [4]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.takeLast(10)).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[
                                                        /* Pull */0,
                                                        /* Pull */0,
                                                        /* Pull */0
                                                      ],
                                                      /* array */[]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.takeLast(10)).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[
                                                              /* Pull */0,
                                                              /* Pull */0
                                                            ],
                                                            /* array */[]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("takeWhile", (function () {
                Jest.test("only lets the last n values through on an entirely new source", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var source = Wonka.takeWhile((function (x) {
                                  return x <= 2;
                                }))((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else {
                                                    var i = num[0];
                                                    num[0] = num[0] + 1 | 0;
                                                    return sink(/* Push */Block.__(1, [i]));
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [2]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.test("accepts the end of the source when max number of emissions is not reached", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var source = Wonka.takeWhile((function (x) {
                                  return x <= 5;
                                }))((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else {
                                                    var i = num[0];
                                                    if (i < 2) {
                                                      num[0] = num[0] + 1 | 0;
                                                      return sink(/* Push */Block.__(1, [i]));
                                                    } else {
                                                      return sink(/* End */0);
                                                    }
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.takeWhile((function (param) {
                                            return true;
                                          }))).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                Jest.testPromise("follows the spec for listenables when ending the source", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.takeWhile((function (param) {
                                            return false;
                                          }))).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[/* Close */1],
                                                      /* array */[/* End */0]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.takeWhile((function (param) {
                                                  return true;
                                                }))).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[/* Close */1],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("takeUntil", (function () {
                Jest.test("only lets the last n values through on an entirely new source", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var notify = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var notifier = function (sink) {
                          notify[0] = (function (signal) {
                              if (signal) {
                                return /* () */0;
                              } else {
                                return sink(/* Push */Block.__(1, [0]));
                              }
                            });
                          return sink(/* Start */Block.__(0, [Wonka_helpers.talkbackPlaceholder]));
                        };
                        var source = Wonka.takeUntil(notifier)((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal || num[0] > 4) {
                                                    return /* () */0;
                                                  } else {
                                                    var i = num[0];
                                                    if (i === 3) {
                                                      Curry._1(notify[0], /* Pull */0);
                                                    }
                                                    num[0] = num[0] + 1 | 0;
                                                    return sink(/* Push */Block.__(1, [i]));
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [2]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.test("accepts the end of the source when max number of emissions is not reached", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var notifier = function (sink) {
                          return sink(/* Start */Block.__(0, [Wonka_helpers.talkbackPlaceholder]));
                        };
                        var source = Wonka.takeUntil(notifier)((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else {
                                                    var i = num[0];
                                                    if (num[0] <= 2) {
                                                      num[0] = num[0] + 1 | 0;
                                                      return sink(/* Push */Block.__(1, [i]));
                                                    } else {
                                                      return sink(/* End */0);
                                                    }
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [2]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.takeUntil(Wonka.never)).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                Jest.testPromise("follows the spec for listenables when ending the source", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.takeUntil(Wonka.fromValue(0))).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[/* Close */1],
                                                      /* array */[/* End */0]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.takeUntil(Wonka.never)).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[/* Close */1],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("skip", (function () {
                Jest.test("only lets values through after a number of values have been filtered out", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var source = Wonka.skip(2)((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else if (num[0] <= 4) {
                                                    var i = num[0];
                                                    num[0] = num[0] + 1 | 0;
                                                    return sink(/* Push */Block.__(1, [i]));
                                                  } else {
                                                    return sink(/* End */0);
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [3]),
                                    /* Push */Block.__(1, [4]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.skip(0)).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                Jest.testPromise("follows the spec for listenables when skipping the source", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.skip(10)).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[
                                                        /* Pull */0,
                                                        /* Pull */0
                                                      ],
                                                      /* array */[/* End */0]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.skip(10)).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[
                                                              /* Pull */0,
                                                              /* Close */1
                                                            ],
                                                            /* array */[]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("skipWhile", (function () {
                Jest.test("only lets values through after the predicate returned false, including the first such value", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var source = Wonka.skipWhile((function (x) {
                                  return x <= 2;
                                }))((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else if (num[0] <= 4) {
                                                    var i = num[0];
                                                    num[0] = num[0] + 1 | 0;
                                                    return sink(/* Push */Block.__(1, [i]));
                                                  } else {
                                                    return sink(/* End */0);
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [3]),
                                    /* Push */Block.__(1, [4]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.skipWhile((function (param) {
                                            return false;
                                          }))).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                Jest.testPromise("follows the spec for listenables when skipping the source", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.skipWhile((function (param) {
                                            return true;
                                          }))).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[
                                                        /* Pull */0,
                                                        /* Pull */0
                                                      ],
                                                      /* array */[/* End */0]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.skipWhile((function (param) {
                                                  return false;
                                                }))).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[/* Close */1],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("skipUntil", (function () {
                Jest.test("only lets values through after the notifier emits a value", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var notify = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var notifier = function (sink) {
                          notify[0] = (function (signal) {
                              if (signal) {
                                return /* () */0;
                              } else {
                                return sink(/* Push */Block.__(1, [0]));
                              }
                            });
                          return sink(/* Start */Block.__(0, [Wonka_helpers.talkbackPlaceholder]));
                        };
                        var source = Wonka.skipUntil(notifier)((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else if (num[0] <= 4) {
                                                    var i = num[0];
                                                    if (i === 3) {
                                                      Curry._1(notify[0], /* Pull */0);
                                                    }
                                                    num[0] = num[0] + 1 | 0;
                                                    return sink(/* Push */Block.__(1, [i]));
                                                  } else {
                                                    return sink(/* End */0);
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[
                                    /* Push */Block.__(1, [3]),
                                    /* Push */Block.__(1, [4]),
                                    /* End */0
                                  ], Jest.Expect[/* expect */0](res));
                      }));
                Jest.test("accepts the end of the source when max number of emissions is not reached", (function (param) {
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var num = /* record */[/* contents */1];
                        var notifier = function (sink) {
                          return sink(/* Start */Block.__(0, [Wonka_helpers.talkbackPlaceholder]));
                        };
                        var source = Wonka.skipUntil(notifier)((function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else {
                                                    var i = num[0];
                                                    if (i < 2) {
                                                      num[0] = num[0] + 1 | 0;
                                                      return sink(/* Push */Block.__(1, [i]));
                                                    } else {
                                                      return sink(/* End */0);
                                                    }
                                                  }
                                                })]));
                              }));
                        var res = /* array */[];
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number" || signal.tag) {
                                  res.push(signal);
                                  return /* () */0;
                                } else {
                                  talkback[0] = signal[0];
                                  return /* () */0;
                                }
                              }));
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        talkback[0](/* Pull */0);
                        return Jest.Expect[/* toEqual */12](/* array */[/* End */0], Jest.Expect[/* expect */0](res));
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.skipUntil(Wonka.never)).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[
                                                        /* Pull */0,
                                                        /* Pull */0,
                                                        /* Pull */0
                                                      ],
                                                      /* array */[/* End */0]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                Jest.testPromise("follows the spec for listenables when skipping the source", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable(Wonka.skipUntil(Wonka.fromValue(0))).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[/* Pull */0],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd(Wonka.skipUntil(Wonka.fromValue(0))).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[
                                                              /* Pull */0,
                                                              /* Close */1
                                                            ],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        describe("flatten", (function () {
                return Jest.test("merges the result of multiple pullables into its source", (function (param) {
                              var talkback = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var source = Wonka.flatten(Wonka.fromList(/* :: */[
                                        Wonka.fromList(/* :: */[
                                              1,
                                              /* :: */[
                                                2,
                                                /* [] */0
                                              ]
                                            ]),
                                        /* :: */[
                                          Wonka.fromList(/* :: */[
                                                1,
                                                /* :: */[
                                                  2,
                                                  /* [] */0
                                                ]
                                              ]),
                                          /* [] */0
                                        ]
                                      ]));
                              var res = /* array */[];
                              Curry._1(source, (function (signal) {
                                      if (typeof signal === "number" || signal.tag) {
                                        res.push(signal);
                                        return /* () */0;
                                      } else {
                                        talkback[0] = signal[0];
                                        return /* () */0;
                                      }
                                    }));
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              talkback[0](/* Pull */0);
                              return Jest.Expect[/* toEqual */12](/* array */[
                                          /* Push */Block.__(1, [1]),
                                          /* Push */Block.__(1, [2]),
                                          /* Push */Block.__(1, [1]),
                                          /* Push */Block.__(1, [2]),
                                          /* End */0
                                        ], Jest.Expect[/* expect */0](res));
                            }));
              }));
        describe("switchMap", (function () {
                afterEach((function () {
                        jest.useRealTimers();
                        return /* () */0;
                      }));
                Jest.test("maps from a source and switches to a new source", (function (param) {
                        var a = Wonka.fromList(/* :: */[
                              1,
                              /* :: */[
                                2,
                                /* :: */[
                                  3,
                                  /* [] */0
                                ]
                              ]
                            ]);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = Wonka.switchMap((function (x) {
                                  return Wonka.fromList(/* :: */[
                                              Caml_int32.imul(x, x),
                                              /* [] */0
                                            ]);
                                }))(a);
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [4]),
                                    /* Push */Block.__(1, [9]),
                                    /* End */0
                                  ]);
                      }));
                Jest.test("unsubscribes from previous subscriptions", (function (param) {
                        jest.useFakeTimers();
                        var a = Wonka.interval(100);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = Wonka.take(5)(Wonka.switchMap((function (param) {
                                      return Wonka.interval(25);
                                    }))(a));
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        jest.runTimersToTime(300);
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                    /* Push */Block.__(1, [0]),
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [2]),
                                    /* Push */Block.__(1, [0]),
                                    /* Push */Block.__(1, [1]),
                                    /* End */0
                                  ]);
                      }));
                Jest.testPromise("follows the spec for listenables", undefined, (function (param) {
                        return Wonka_thelpers.testWithListenable((function (source) {
                                        return Wonka.switchMap((function (x) {
                                                        return x;
                                                      }))(Wonka.fromList(/* :: */[
                                                        source,
                                                        /* [] */0
                                                      ]));
                                      })).then((function (x) {
                                      return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                      /* array */[
                                                        /* Pull */0,
                                                        /* Pull */0,
                                                        /* Pull */0
                                                      ],
                                                      /* array */[
                                                        /* Push */Block.__(1, [1]),
                                                        /* Push */Block.__(1, [2]),
                                                        /* End */0
                                                      ]
                                                    ], Jest.Expect[/* expect */0](x)));
                                    }));
                      }));
                return Jest.testPromise("ends itself and source when its talkback receives the End signal", undefined, (function (param) {
                              return Wonka_thelpers.testTalkbackEnd((function (source) {
                                              return Wonka.switchMap((function (x) {
                                                              return x;
                                                            }))(Wonka.fromList(/* :: */[
                                                              source,
                                                              /* [] */0
                                                            ]));
                                            })).then((function (x) {
                                            return Promise.resolve(Jest.Expect[/* toEqual */12](/* tuple */[
                                                            /* array */[
                                                              /* Pull */0,
                                                              /* Pull */0,
                                                              /* Close */1
                                                            ],
                                                            /* array */[/* Push */Block.__(1, [1])]
                                                          ], Jest.Expect[/* expect */0](x)));
                                          }));
                            }));
              }));
        return /* () */0;
      }));

describe("sink factories", (function () {
        describe("forEach", (function () {
                return Jest.test("calls a function for each emission of the passed source", (function (param) {
                              var i = /* record */[/* contents */0];
                              var nums = /* array */[];
                              var source = function (sink) {
                                return sink(/* Start */Block.__(0, [(function (signal) {
                                                  if (signal) {
                                                    return /* () */0;
                                                  } else if (i[0] < 4) {
                                                    var num = i[0];
                                                    i[0] = i[0] + 1 | 0;
                                                    return sink(/* Push */Block.__(1, [num]));
                                                  } else {
                                                    return sink(/* End */0);
                                                  }
                                                })]));
                              };
                              Wonka.forEach((function (x) {
                                        nums.push(x);
                                        return /* () */0;
                                      }))(source);
                              return Jest.Expect[/* toEqual */12](/* array */[
                                          0,
                                          1,
                                          2,
                                          3
                                        ], Jest.Expect[/* expect */0](nums));
                            }));
              }));
        describe("subscribe", (function () {
                return Jest.test("calls a function for each emission of the passed source and stops when unsubscribed", (function (param) {
                              var i = /* record */[/* contents */0];
                              var nums = /* array */[];
                              var push = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var source = function (sink) {
                                push[0] = (function (param) {
                                    var num = i[0];
                                    i[0] = i[0] + 1 | 0;
                                    return sink(/* Push */Block.__(1, [num]));
                                  });
                                return sink(/* Start */Block.__(0, [Wonka_helpers.talkbackPlaceholder]));
                              };
                              var match = Wonka.subscribe((function (x) {
                                        nums.push(x);
                                        return /* () */0;
                                      }))(source);
                              Curry._1(push[0], /* () */0);
                              Curry._1(push[0], /* () */0);
                              Curry._1(match[/* unsubscribe */0], /* () */0);
                              Curry._1(push[0], /* () */0);
                              Curry._1(push[0], /* () */0);
                              return Jest.Expect[/* toEqual */12](/* array */[
                                          0,
                                          1
                                        ], Jest.Expect[/* expect */0](nums));
                            }));
              }));
        return /* () */0;
      }));

describe("chains (integration)", (function () {
        return Jest.test("fromArray, map, forEach", (function (param) {
                      var input = $$Array.mapi((function (i, param) {
                              return i;
                            }), Caml_array.caml_make_vect(1000, 1));
                      var output = function (param) {
                        return $$Array.map((function (x) {
                                      return String(x);
                                    }), param);
                      };
                      var actual = /* array */[];
                      Wonka.forEach((function (x) {
                                actual.push(x);
                                return /* () */0;
                              }))(Wonka.map((function (x) {
                                    return String(x);
                                  }))(Wonka.fromArray(input)));
                      return Jest.Expect[/* toEqual */12](output, Jest.Expect[/* expect */0](output));
                    }));
      }));

describe("subject", (function () {
        Jest.test("sends values passed to .next to puller sinks", (function (param) {
                var signals = /* array */[];
                var subject = Wonka.makeSubject(/* () */0);
                Curry._1(subject[/* source */0], (function (signal) {
                        if (typeof signal === "number" || signal.tag) {
                          signals.push(signal);
                          return /* () */0;
                        } else {
                          return /* () */0;
                        }
                      }));
                Curry._1(subject[/* next */1], 10);
                Curry._1(subject[/* next */1], 20);
                Curry._1(subject[/* next */1], 30);
                Curry._1(subject[/* next */1], 40);
                Curry._1(subject[/* complete */2], /* () */0);
                return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                            /* Push */Block.__(1, [10]),
                            /* Push */Block.__(1, [20]),
                            /* Push */Block.__(1, [30]),
                            /* Push */Block.__(1, [40]),
                            /* End */0
                          ]);
              }));
        Jest.test("handles multiple sinks", (function (param) {
                var talkback = /* record */[/* contents */(function (param) {
                      return /* () */0;
                    })];
                var signalsOne = /* array */[];
                var signalsTwo = /* array */[];
                var subject = Wonka.makeSubject(/* () */0);
                Curry._1(subject[/* source */0], (function (signal) {
                        if (typeof signal === "number" || signal.tag) {
                          signalsOne.push(signal);
                          return /* () */0;
                        } else {
                          talkback[0] = signal[0];
                          return /* () */0;
                        }
                      }));
                Curry._1(subject[/* source */0], (function (signal) {
                        if (typeof signal === "number" || signal.tag) {
                          signalsTwo.push(signal);
                          return /* () */0;
                        } else {
                          return /* () */0;
                        }
                      }));
                Curry._1(subject[/* next */1], 10);
                Curry._1(subject[/* next */1], 20);
                Curry._1(subject[/* next */1], 30);
                talkback[0](/* Close */1);
                Curry._1(subject[/* next */1], 40);
                Curry._1(subject[/* next */1], 50);
                Curry._1(subject[/* complete */2], /* () */0);
                return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](/* tuple */[
                                signalsOne,
                                signalsTwo
                              ]), /* tuple */[
                            /* array */[
                              /* Push */Block.__(1, [10]),
                              /* Push */Block.__(1, [20]),
                              /* Push */Block.__(1, [30])
                            ],
                            /* array */[
                              /* Push */Block.__(1, [10]),
                              /* Push */Block.__(1, [20]),
                              /* Push */Block.__(1, [30]),
                              /* Push */Block.__(1, [40]),
                              /* Push */Block.__(1, [50]),
                              /* End */0
                            ]
                          ]);
              }));
        return Jest.test("handles multiple sinks that subscribe and close at different times", (function (param) {
                      var talkbackOne = /* record */[/* contents */(function (param) {
                            return /* () */0;
                          })];
                      var talkbackTwo = /* record */[/* contents */(function (param) {
                            return /* () */0;
                          })];
                      var signalsOne = /* array */[];
                      var signalsTwo = /* array */[];
                      var subject = Wonka.makeSubject(/* () */0);
                      Curry._1(subject[/* next */1], 10);
                      Curry._1(subject[/* next */1], 20);
                      Curry._1(subject[/* source */0], (function (signal) {
                              if (typeof signal === "number" || signal.tag) {
                                signalsOne.push(signal);
                                return /* () */0;
                              } else {
                                talkbackOne[0] = signal[0];
                                return /* () */0;
                              }
                            }));
                      Curry._1(subject[/* next */1], 30);
                      Curry._1(subject[/* source */0], (function (signal) {
                              if (typeof signal === "number" || signal.tag) {
                                signalsTwo.push(signal);
                                return /* () */0;
                              } else {
                                talkbackTwo[0] = signal[0];
                                return /* () */0;
                              }
                            }));
                      Curry._1(subject[/* next */1], 40);
                      Curry._1(subject[/* next */1], 50);
                      talkbackTwo[0](/* Close */1);
                      Curry._1(subject[/* next */1], 60);
                      talkbackOne[0](/* Close */1);
                      Curry._1(subject[/* next */1], 70);
                      Curry._1(subject[/* complete */2], /* () */0);
                      return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](/* tuple */[
                                      signalsOne,
                                      signalsTwo
                                    ]), /* tuple */[
                                  /* array */[
                                    /* Push */Block.__(1, [30]),
                                    /* Push */Block.__(1, [40]),
                                    /* Push */Block.__(1, [50]),
                                    /* Push */Block.__(1, [60])
                                  ],
                                  /* array */[
                                    /* Push */Block.__(1, [40]),
                                    /* Push */Block.__(1, [50])
                                  ]
                                ]);
                    }));
      }));

describe("web operators", (function () {
        describe("delay", (function () {
                afterEach((function () {
                        jest.useRealTimers();
                        return /* () */0;
                      }));
                Jest.test("should not emit values before specified delay", (function (param) {
                        jest.useFakeTimers();
                        var a = Wonka.fromList(/* :: */[
                              1,
                              /* :: */[
                                2,
                                /* :: */[
                                  3,
                                  /* [] */0
                                ]
                              ]
                            ]);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = Wonka.take(3)(WonkaJs.delay(200)(a));
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[]);
                      }));
                Jest.test("should emit values after specified delay", (function (param) {
                        jest.useFakeTimers();
                        var a = Wonka.fromList(/* :: */[
                              1,
                              /* :: */[
                                2,
                                /* :: */[
                                  3,
                                  /* [] */0
                                ]
                              ]
                            ]);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = Wonka.take(3)(WonkaJs.delay(200)(a));
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        jest.runTimersToTime(400);
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [2])
                                  ]);
                      }));
                return Jest.test("should emit an End signal when the source has emitted all values", (function (param) {
                              jest.useFakeTimers();
                              var a = Wonka.fromList(/* :: */[
                                    1,
                                    /* :: */[
                                      2,
                                      /* :: */[
                                        3,
                                        /* [] */0
                                      ]
                                    ]
                                  ]);
                              var talkback = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var signals = /* array */[];
                              var source = Wonka.take(3)(WonkaJs.delay(200)(a));
                              Curry._1(source, (function (signal) {
                                      if (typeof signal === "number") {
                                        signals.push(signal);
                                        return /* () */0;
                                      } else if (signal.tag) {
                                        signals.push(signal);
                                        return talkback[0](/* Pull */0);
                                      } else {
                                        var x = signal[0];
                                        talkback[0] = x;
                                        return x(/* Pull */0);
                                      }
                                    }));
                              jest.runTimersToTime(600);
                              return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                          /* Push */Block.__(1, [1]),
                                          /* Push */Block.__(1, [2]),
                                          /* Push */Block.__(1, [3]),
                                          /* End */0
                                        ]);
                            }));
              }));
        describe("throttle", (function () {
                afterEach((function () {
                        jest.useRealTimers();
                        return /* () */0;
                      }));
                Jest.test("should not emit values before specified throttle (but include values on leading edge)", (function (param) {
                        jest.useFakeTimers();
                        var a = Wonka.interval(100);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = Wonka.take(3)(WonkaJs.throttle((function (param) {
                                      return 600;
                                    }))(a));
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        jest.runTimersToTime(400);
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[/* Push */Block.__(1, [0])]);
                      }));
                Jest.test("should throttle emissions by the specified throttle", (function (param) {
                        jest.useFakeTimers();
                        var a = Wonka.interval(100);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = Wonka.take(3)(WonkaJs.throttle((function (param) {
                                      return 600;
                                    }))(a));
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        jest.runTimersToTime(1000);
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                    /* Push */Block.__(1, [0]),
                                    /* Push */Block.__(1, [7])
                                  ]);
                      }));
                return Jest.test("should emit an End signal when the source has emitted all values", (function (param) {
                              jest.useFakeTimers();
                              var a = Wonka.interval(100);
                              var talkback = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var signals = /* array */[];
                              var source = Wonka.take(3)(WonkaJs.throttle((function (param) {
                                            return 600;
                                          }))(a));
                              Curry._1(source, (function (signal) {
                                      if (typeof signal === "number") {
                                        signals.push(signal);
                                        return /* () */0;
                                      } else if (signal.tag) {
                                        signals.push(signal);
                                        return talkback[0](/* Pull */0);
                                      } else {
                                        var x = signal[0];
                                        talkback[0] = x;
                                        return x(/* Pull */0);
                                      }
                                    }));
                              jest.runTimersToTime(1500);
                              return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                          /* Push */Block.__(1, [0]),
                                          /* Push */Block.__(1, [7]),
                                          /* Push */Block.__(1, [14]),
                                          /* End */0
                                        ]);
                            }));
              }));
        describe("debounce", (function () {
                afterEach((function () {
                        jest.useRealTimers();
                        return /* () */0;
                      }));
                Jest.test("should not emit values if emitted before the debounce specified by the duration selector", (function (param) {
                        jest.useFakeTimers();
                        var a = Wonka.fromList(/* :: */[
                              1,
                              /* :: */[
                                2,
                                /* :: */[
                                  3,
                                  /* [] */0
                                ]
                              ]
                            ]);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = Wonka.take(3)(WonkaJs.debounce((function (param) {
                                      return 1000;
                                    }))(a));
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        jest.runTimersToTime(500);
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[]);
                      }));
                Jest.test("should debounce emissions based on the duration selector", (function (param) {
                        jest.useFakeTimers();
                        var a = Wonka.fromList(/* :: */[
                              1,
                              /* :: */[
                                2,
                                /* :: */[
                                  3,
                                  /* [] */0
                                ]
                              ]
                            ]);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = Wonka.take(3)(WonkaJs.debounce((function (param) {
                                      return 1000;
                                    }))(a));
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        jest.runTimersToTime(2000);
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [2])
                                  ]);
                      }));
                return Jest.test("should emit an End signal when the source has emitted all values", (function (param) {
                              jest.useFakeTimers();
                              var a = Wonka.fromList(/* :: */[
                                    1,
                                    /* :: */[
                                      2,
                                      /* :: */[
                                        3,
                                        /* [] */0
                                      ]
                                    ]
                                  ]);
                              var talkback = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var signals = /* array */[];
                              var source = Wonka.take(3)(WonkaJs.debounce((function (param) {
                                            return 1000;
                                          }))(a));
                              Curry._1(source, (function (signal) {
                                      if (typeof signal === "number") {
                                        signals.push(signal);
                                        return /* () */0;
                                      } else if (signal.tag) {
                                        signals.push(signal);
                                        return talkback[0](/* Pull */0);
                                      } else {
                                        var x = signal[0];
                                        talkback[0] = x;
                                        return x(/* Pull */0);
                                      }
                                    }));
                              jest.runTimersToTime(3000);
                              return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                          /* Push */Block.__(1, [1]),
                                          /* Push */Block.__(1, [2]),
                                          /* Push */Block.__(1, [3]),
                                          /* End */0
                                        ]);
                            }));
              }));
        describe("sample", (function () {
                afterEach((function () {
                        jest.useRealTimers();
                        return /* () */0;
                      }));
                Jest.test("should sample the last emitted value from a source", (function (param) {
                        jest.useFakeTimers();
                        var a = Wonka.interval(50);
                        var talkback = /* record */[/* contents */(function (param) {
                              return /* () */0;
                            })];
                        var signals = /* array */[];
                        var source = WonkaJs.sample(Wonka.interval(100))(a);
                        Curry._1(source, (function (signal) {
                                if (typeof signal === "number") {
                                  signals.push(signal);
                                  return /* () */0;
                                } else if (signal.tag) {
                                  signals.push(signal);
                                  return talkback[0](/* Pull */0);
                                } else {
                                  var x = signal[0];
                                  talkback[0] = x;
                                  return x(/* Pull */0);
                                }
                              }));
                        jest.runTimersToTime(200);
                        return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                    /* Push */Block.__(1, [1]),
                                    /* Push */Block.__(1, [3])
                                  ]);
                      }));
                return Jest.test("should emit an End signal when the source has emitted all values", (function (param) {
                              jest.useFakeTimers();
                              var a = Wonka.interval(50);
                              var talkback = /* record */[/* contents */(function (param) {
                                    return /* () */0;
                                  })];
                              var signals = /* array */[];
                              var source = Wonka.take(3)(WonkaJs.sample(Wonka.interval(100))(a));
                              Curry._1(source, (function (signal) {
                                      if (typeof signal === "number") {
                                        signals.push(signal);
                                        return /* () */0;
                                      } else if (signal.tag) {
                                        signals.push(signal);
                                        return talkback[0](/* Pull */0);
                                      } else {
                                        var x = signal[0];
                                        talkback[0] = x;
                                        return x(/* Pull */0);
                                      }
                                    }));
                              jest.runTimersToTime(300);
                              return Curry._2(Jest.Expect[/* Operators */24][/* = */5], Jest.Expect[/* expect */0](signals), /* array */[
                                          /* Push */Block.__(1, [1]),
                                          /* Push */Block.__(1, [3]),
                                          /* Push */Block.__(1, [5]),
                                          /* End */0
                                        ]);
                            }));
              }));
        return /* () */0;
      }));

var it = Jest.test;

exports.it = it;
/*  Not a pure module */
