'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Wonka_helpers = require("../wonka_helpers.js");
var MutableQueue_js = require("bs-rebel/lib/js/src/js/MutableQueue_js.js");
var Wonka_source_fromArray = require("../sources/wonka_source_fromArray.js");

function concatMap(f) {
  return (function (source) {
      return (function (sink) {
          var state = /* record */[
            /* inputQueue */new Array(),
            /* outerTalkback */Wonka_helpers.talkbackPlaceholder,
            /* innerTalkback */Wonka_helpers.talkbackPlaceholder,
            /* innerActive */false,
            /* closed */false,
            /* ended */false
          ];
          var applyInnerSource = function (innerSource) {
            return Curry._1(innerSource, (function (signal) {
                          if (typeof signal === "number") {
                            state[/* innerActive */3] = false;
                            state[/* innerTalkback */2] = Wonka_helpers.talkbackPlaceholder;
                            var match = state[/* inputQueue */0].shift();
                            if (match !== undefined) {
                              return applyInnerSource(f(Caml_option.valFromOption(match)));
                            } else if (state[/* ended */5]) {
                              return sink(/* End */0);
                            } else {
                              return /* () */0;
                            }
                          } else if (signal.tag) {
                            if (state[/* closed */4]) {
                              return /* () */0;
                            } else {
                              sink(/* Push */Block.__(1, [signal[0]]));
                              return state[/* innerTalkback */2](/* Pull */0);
                            }
                          } else {
                            var tb = signal[0];
                            state[/* innerActive */3] = true;
                            state[/* innerTalkback */2] = tb;
                            return tb(/* Pull */0);
                          }
                        }));
          };
          Curry._1(source, (function (signal) {
                  if (typeof signal === "number") {
                    if (state[/* ended */5]) {
                      return /* () */0;
                    } else {
                      state[/* ended */5] = true;
                      if (!state[/* innerActive */3] && MutableQueue_js.isEmpty(state[/* inputQueue */0])) {
                        return sink(/* End */0);
                      } else {
                        return 0;
                      }
                    }
                  } else if (signal.tag) {
                    if (state[/* ended */5]) {
                      return /* () */0;
                    } else {
                      var x = signal[0];
                      if (state[/* innerActive */3]) {
                        state[/* inputQueue */0].push(x);
                      } else {
                        applyInnerSource(f(x));
                      }
                      return state[/* outerTalkback */1](/* Pull */0);
                    }
                  } else {
                    var tb = signal[0];
                    state[/* outerTalkback */1] = tb;
                    return tb(/* Pull */0);
                  }
                }));
          return sink(/* Start */Block.__(0, [(function (signal) {
                            if (signal) {
                              state[/* innerTalkback */2](/* Close */1);
                              if (state[/* ended */5]) {
                                return 0;
                              } else {
                                state[/* ended */5] = true;
                                state[/* closed */4] = true;
                                state[/* outerTalkback */1](/* Close */1);
                                state[/* innerTalkback */2] = Wonka_helpers.talkbackPlaceholder;
                                return /* () */0;
                              }
                            } else if (state[/* ended */5]) {
                              return 0;
                            } else {
                              return state[/* innerTalkback */2](/* Pull */0);
                            }
                          })]));
        });
    });
}

function concatAll(source) {
  return concatMap((function (x) {
                  return x;
                }))(source);
}

function concat(sources) {
  return concatMap((function (x) {
                  return x;
                }))(Wonka_source_fromArray.fromArray(sources));
}

exports.concatMap = concatMap;
exports.concat = concat;
exports.concatAll = concatAll;
/* No side effect */
