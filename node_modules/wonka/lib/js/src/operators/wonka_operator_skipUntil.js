'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Wonka_helpers = require("../wonka_helpers.js");

function skipUntil(notifier) {
  return (function (source) {
      return (function (sink) {
          var state = /* record */[
            /* skip */true,
            /* ended */false,
            /* gotSignal */false,
            /* sourceTalkback */Wonka_helpers.talkbackPlaceholder,
            /* notifierTalkback */Wonka_helpers.talkbackPlaceholder
          ];
          Curry._1(source, (function (signal) {
                  if (typeof signal === "number") {
                    if (state[/* skip */0]) {
                      state[/* notifierTalkback */4](/* Close */1);
                    }
                    state[/* ended */1] = true;
                    return sink(/* End */0);
                  } else if (signal.tag) {
                    if (state[/* skip */0] && !state[/* ended */1]) {
                      return state[/* sourceTalkback */3](/* Pull */0);
                    } else if (state[/* ended */1]) {
                      return /* () */0;
                    } else {
                      state[/* gotSignal */2] = false;
                      return sink(signal);
                    }
                  } else {
                    var tb = signal[0];
                    state[/* sourceTalkback */3] = tb;
                    return Curry._1(notifier, (function (signal) {
                                  if (typeof signal === "number") {
                                    return /* () */0;
                                  } else if (signal.tag) {
                                    state[/* skip */0] = false;
                                    return state[/* notifierTalkback */4](/* Close */1);
                                  } else {
                                    var innerTb = signal[0];
                                    state[/* notifierTalkback */4] = innerTb;
                                    innerTb(/* Pull */0);
                                    return tb(/* Pull */0);
                                  }
                                }));
                  }
                }));
          return sink(/* Start */Block.__(0, [(function (signal) {
                            if (signal) {
                              if (state[/* skip */0]) {
                                state[/* notifierTalkback */4](/* Close */1);
                              }
                              state[/* ended */1] = true;
                              return state[/* sourceTalkback */3](/* Close */1);
                            } else if (!state[/* gotSignal */2] && !state[/* ended */1]) {
                              state[/* gotSignal */2] = true;
                              return state[/* sourceTalkback */3](/* Pull */0);
                            } else {
                              return /* () */0;
                            }
                          })]));
        });
    });
}

exports.skipUntil = skipUntil;
/* No side effect */
