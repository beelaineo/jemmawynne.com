'use strict';

var Block = require("bs-platform/lib/js/block.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_option = require("bs-platform/lib/js/caml_option.js");
var Wonka_helpers = require("../wonka_helpers.js");

function combine(sourceA) {
  return (function (sourceB) {
      return (function (sink) {
          var state = /* record */[
            /* talkbackA */Wonka_helpers.talkbackPlaceholder,
            /* talkbackB */Wonka_helpers.talkbackPlaceholder,
            /* lastValA */undefined,
            /* lastValB */undefined,
            /* gotSignal */false,
            /* endCounter */0,
            /* ended */false
          ];
          Curry._1(sourceA, (function (signal) {
                  var match = state[/* lastValB */3];
                  if (typeof signal === "number") {
                    if (state[/* endCounter */5] < 1) {
                      state[/* endCounter */5] = state[/* endCounter */5] + 1 | 0;
                      return /* () */0;
                    } else if (state[/* ended */6]) {
                      return /* () */0;
                    } else {
                      state[/* ended */6] = true;
                      return sink(/* End */0);
                    }
                  } else if (signal.tag) {
                    var a = signal[0];
                    if (match !== undefined) {
                      if (state[/* ended */6]) {
                        return /* () */0;
                      } else {
                        state[/* lastValA */2] = Caml_option.some(a);
                        state[/* gotSignal */4] = false;
                        return sink(/* Push */Block.__(1, [/* tuple */[
                                        a,
                                        Caml_option.valFromOption(match)
                                      ]]));
                      }
                    } else {
                      state[/* lastValA */2] = Caml_option.some(a);
                      state[/* gotSignal */4] = false;
                      return /* () */0;
                    }
                  } else {
                    state[/* talkbackA */0] = signal[0];
                    return /* () */0;
                  }
                }));
          Curry._1(sourceB, (function (signal) {
                  var match = state[/* lastValA */2];
                  if (typeof signal === "number") {
                    if (state[/* endCounter */5] < 1) {
                      state[/* endCounter */5] = state[/* endCounter */5] + 1 | 0;
                      return /* () */0;
                    } else if (state[/* ended */6]) {
                      return /* () */0;
                    } else {
                      state[/* ended */6] = true;
                      return sink(/* End */0);
                    }
                  } else if (signal.tag) {
                    var b = signal[0];
                    if (match !== undefined) {
                      if (state[/* ended */6]) {
                        return /* () */0;
                      } else {
                        state[/* lastValB */3] = Caml_option.some(b);
                        state[/* gotSignal */4] = false;
                        return sink(/* Push */Block.__(1, [/* tuple */[
                                        Caml_option.valFromOption(match),
                                        b
                                      ]]));
                      }
                    } else {
                      state[/* lastValB */3] = Caml_option.some(b);
                      state[/* gotSignal */4] = false;
                      return /* () */0;
                    }
                  } else {
                    state[/* talkbackB */1] = signal[0];
                    return /* () */0;
                  }
                }));
          return sink(/* Start */Block.__(0, [(function (signal) {
                            if (state[/* ended */6]) {
                              return 0;
                            } else if (signal) {
                              state[/* ended */6] = true;
                              state[/* talkbackA */0](/* Close */1);
                              return state[/* talkbackB */1](/* Close */1);
                            } else if (state[/* gotSignal */4]) {
                              return /* () */0;
                            } else {
                              state[/* gotSignal */4] = true;
                              state[/* talkbackA */0](signal);
                              return state[/* talkbackB */1](signal);
                            }
                          })]));
        });
    });
}

exports.combine = combine;
/* No side effect */
